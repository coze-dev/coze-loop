apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "python-faas.fullname" . }}-configmap
  labels:
    {{- include "python-faas.labels" . | nindent 4 }}
data:
  enhanced_python_faas_server.ts: |
    #!/usr/bin/env deno run --allow-net --allow-env --allow-run

    /// <reference types="https://deno.land/x/deno@v1.45.5/cli/dts/lib.deno.d.ts" />

    /**
     * å¢å¼ºç‰ˆ Python FaaS æœåŠ¡å™¨
     * 
     * è¿™ä¸ªç‰ˆæœ¬æä¾›çœŸæ­£çš„ Python ä»£ç æ‰§è¡Œèƒ½åŠ›ï¼Œè€Œä¸æ˜¯æ¨¡æ‹Ÿå™¨
     * 
     * ç‰¹æ€§ï¼š
     * 1. çœŸæ­£çš„ Python ä»£ç æ‰§è¡Œï¼ˆé€šè¿‡å­è¿›ç¨‹è°ƒç”¨ Pythonï¼‰
     * 2. å®Œæ•´çš„å®‰å…¨æ²™ç®±éš”ç¦»
     * 3. æ”¯æŒå¤æ‚çš„ Python ä»£ç ï¼ŒåŒ…æ‹¬å‡½æ•°å®šä¹‰ã€æ•°æ®å¤„ç†ç­‰
     * 4. ä¿æŒä¸åŸ API çš„å®Œå…¨å…¼å®¹
     * 5. åŸºäº Deno çš„å®‰å…¨æ‰§è¡Œç¯å¢ƒ
     * 6. æ”¯æŒ stdoutã€stderr å’Œ return_val æ•è·
     * 
     * å®‰å…¨æªæ–½ï¼š
     * - é€šè¿‡ Docker å®¹å™¨éš”ç¦»
     * - ä»£ç é™æ€åˆ†ææ£€æŸ¥å±é™©æ¨¡å¼
     * - æ¨¡å—å¯¼å…¥é»‘åå•æ§åˆ¶
     * - æ‰§è¡Œè¶…æ—¶æ§åˆ¶
     * - èµ„æºä½¿ç”¨é™åˆ¶
     */

    // ==================== ç±»å‹å®šä¹‰ ====================

    interface ExecutionResult {
      stdout: string;
      stderr: string;
      returnValue: string;
      metadata: {
        duration: number;
        exitCode: number;
        timedOut: boolean;
      };
    }

    interface HealthStatus {
      status: string;
      timestamp: string;
      runtime: string;
      version: string;
      execution_count: number;
      python_version?: string;
      security: {
        sandbox: string;
        isolation: string;
        permissions: string;
      };
    }

    // ==================== å®‰å…¨ä»£ç æ£€æŸ¥å™¨ ====================

    class SecurityCodeChecker {
      private static readonly DANGEROUS_PATTERNS = [
        // å±é™©å‡½æ•°è°ƒç”¨
        /open\s*\(/,
        /file\s*\(/,
        /exec\s*\(/,
        /eval\s*\(/,
        /__import__\s*\(/,
        /compile\s*\(/,
        
        // ç³»ç»Ÿè°ƒç”¨æ¨¡å¼
        /subprocess\./,
        /os\.system/,
        /os\.popen/,
        /os\.spawn/,
        /os\.exec/,
        
        // ç½‘ç»œè®¿é—®æ¨¡å¼
        /socket\./,
        /urllib\./,
        /http\./,
        /requests\./,
        
        // æ–‡ä»¶ç³»ç»Ÿè®¿é—®æ¨¡å¼
        /with\s+open\s*\(/,
        /open\s*\([^)]*['"]/,
      ];

      // é»‘åå•ç­–ç•¥ï¼šåªé˜»æ­¢å±é™©çš„ç³»ç»Ÿæ¨¡å—
      private static readonly DANGEROUS_SYSTEM_MODULES = new Set([
        // ç³»ç»Ÿè®¿é—®æ¨¡å—
        'os', 'subprocess', 'socket', 'urllib', 'http', 'requests',
        
        // ç½‘ç»œé€šä¿¡æ¨¡å—
        'ftplib', 'poplib', 'imaplib', 'smtplib', 'telnetlib', 'webbrowser',
        
        // åºåˆ—åŒ–å’ŒæŒä¹…åŒ–æ¨¡å—ï¼ˆå¯èƒ½ä¸å®‰å…¨ï¼‰
        'pickle', 'marshal', 'shelve', 'dbm', 'sqlite3',
        
        // å¤šçº¿ç¨‹å’Œå¤šè¿›ç¨‹æ¨¡å—
        'threading', 'multiprocessing',
        
        // ç³»ç»Ÿåº•å±‚æ¨¡å—
        'ctypes', 'gc', 'signal', 'resource', 'mmap', 'fcntl',
        'termios', 'tty', 'pty', 'grp', 'pwd', 'spwd', 'crypt',
        
        // åŠ¨æ€å¯¼å…¥å’Œä»£ç æ“ä½œæ¨¡å—ï¼ˆå…è®¸ sys å’Œ astï¼‰
        'importlib', 'pkgutil', 'runpy', 'zipimport', 'inspect', 
        'types', 'code', 'codeop', 'compileall', 'dis',
        
        // ç¨‹åºæ§åˆ¶æ¨¡å—
        'atexit',
        
        // å®‰å…¨ç›¸å…³æ¨¡å—ï¼ˆåœ¨æ²™ç®±ç¯å¢ƒä¸­ä¸éœ€è¦ï¼‰
        'ssl', 'hashlib', 'hmac', 'secrets'
      ]);

      /**
       * æ£€æŸ¥ä»£ç å®‰å…¨æ€§
       */
      static checkCodeSecurity(code: string): { safe: boolean; violations: string[] } {
        const violations: string[] = [];

        // æ£€æŸ¥å±é™©æ¨¡å¼
        for (const pattern of this.DANGEROUS_PATTERNS) {
          if (pattern.test(code)) {
            violations.push(`æ£€æµ‹åˆ°å±é™©æ¨¡å¼: ${pattern.source}`);
          }
        }

        // æ£€æŸ¥æ¨¡å—å¯¼å…¥ - é»‘åå•ç­–ç•¥
        const importMatches = code.match(/(?:import|from)\s+(\w+)/g);
        if (importMatches) {
          for (const match of importMatches) {
            const moduleName = match.replace(/(?:import|from)\s+/, '').split('.')[0];
            if (this.DANGEROUS_SYSTEM_MODULES.has(moduleName)) {
              violations.push(`ç¦æ­¢å¯¼å…¥å±é™©ç³»ç»Ÿæ¨¡å—: ${moduleName}`);
            }
          }
        }

        return {
          safe: violations.length === 0,
          violations
        };
      }
    }

    // ==================== Python ä»£ç æ‰§è¡Œå™¨ ====================

    class EnhancedPythonExecutor {
      private executionCount = 0;
      private pythonVersion: string | null = null;

      constructor() {
        this.initializePythonEnvironment();
      }

      /**
       * åˆå§‹åŒ– Python ç¯å¢ƒ
       */
      private async initializePythonEnvironment(): Promise<void> {
        try {
          const process = new Deno.Command("python3", {
            args: ["--version"],
            stdout: "piped",
            stderr: "piped",
          });
          
          const { stdout } = await process.output();
          this.pythonVersion = new TextDecoder().decode(stdout).trim();
          console.log(`ğŸ Python ç¯å¢ƒåˆå§‹åŒ–æˆåŠŸ: ${this.pythonVersion}`);
        } catch (error) {
          console.warn(`âš ï¸ Python ç¯å¢ƒæ£€æŸ¥å¤±è´¥: ${error.message}`);
          this.pythonVersion = "Python 3.x (æœªçŸ¥ç‰ˆæœ¬)";
        }
      }

      /**
       * æ‰§è¡Œ Python ä»£ç ï¼ˆçœŸæ­£çš„æ‰§è¡Œï¼‰
       */
      async executePython(code: string, timeout = 30000): Promise<ExecutionResult> {
        this.executionCount++;
        
        console.log(`ğŸš€ æ‰§è¡Œ Python ä»£ç  (çœŸå®æ‰§è¡Œå™¨)ï¼Œè¶…æ—¶: ${timeout}ms`);
        
        // å®‰å…¨æ£€æŸ¥
        const securityCheck = SecurityCodeChecker.checkCodeSecurity(code);
        if (!securityCheck.safe) {
          return {
            stdout: "",
            stderr: `å®‰å…¨æ£€æŸ¥å¤±è´¥:\n${securityCheck.violations.join('\n')}`,
            returnValue: "",
            metadata: {
              duration: 0,
              exitCode: 1,
              timedOut: false
            }
          };
        }

        try {
          const startTime = Date.now();
          const result = await this.executeRealPython(code, timeout);
          const duration = Date.now() - startTime;
          
          return {
            ...result,
            metadata: {
              ...result.metadata,
              duration
            }
          };
        } catch (error) {
          return {
            stdout: "",
            stderr: `æ‰§è¡Œé”™è¯¯: ${error.message}`,
            returnValue: "",
            metadata: {
              duration: 0,
              exitCode: 1,
              timedOut: error.message.includes('timeout')
            }
          };
        }
      }

      /**
       * çœŸæ­£æ‰§è¡Œ Python ä»£ç 
       */
      private async executeRealPython(code: string, timeout: number): Promise<ExecutionResult> {
        // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
        const tempCodeFile = `/tmp/user_code_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.py`;
        const tempWrapperFile = `/tmp/wrapper_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.py`;
        
        try {
          // å†™å…¥ç”¨æˆ·ä»£ç åˆ°å•ç‹¬æ–‡ä»¶
          await Deno.writeTextFile(tempCodeFile, code);
          
          // åˆ›å»ºå®‰å…¨çš„æ‰§è¡ŒåŒ…è£…å™¨
          const wrapperScript = this.createSafeExecutionWrapper(tempCodeFile);
          await Deno.writeTextFile(tempWrapperFile, wrapperScript);
          
          // æ‰§è¡ŒåŒ…è£…å™¨è„šæœ¬
          const process = new Deno.Command("python3", {
            args: [tempWrapperFile],
            stdout: "piped",
            stderr: "piped",
            env: {
              // è®¾ç½®å®‰å…¨çš„ç¯å¢ƒå˜é‡
              PYTHONPATH: "",
              PYTHONDONTWRITEBYTECODE: "1",
              PYTHONUNBUFFERED: "1",
            }
          });

          // è®¾ç½®è¶…æ—¶
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          try {
            const { stdout, stderr, code: exitCode } = await process.output();
            clearTimeout(timeoutId);
            
            const stdoutText = new TextDecoder().decode(stdout);
            const stderrText = new TextDecoder().decode(stderr);
            
            // æå– return_val çš„ç»“æœ
            const returnValue = this.extractReturnValue(stdoutText);
            
            // æ¸…ç† stdoutï¼Œç§»é™¤ return_val è¾“å‡º
            const cleanStdout = this.cleanStdout(stdoutText);
            
            return {
              stdout: cleanStdout,
              stderr: stderrText,
              returnValue,
              metadata: {
                duration: 0, // å°†åœ¨ä¸Šå±‚è®¾ç½®
                exitCode,
                timedOut: false
              }
            };
            
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
              throw new Error(`æ‰§è¡Œè¶…æ—¶ (${timeout}ms)`);
            }
            throw error;
          }
          
        } finally {
          // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
          try {
            await Deno.remove(tempCodeFile);
            await Deno.remove(tempWrapperFile);
          } catch {
            // å¿½ç•¥æ¸…ç†é”™è¯¯
          }
        }
      }

      /**
       * åˆ›å»ºå®‰å…¨çš„ Python æ‰§è¡ŒåŒ…è£…å™¨
       */
      private createSafeExecutionWrapper(userCodeFile: string): string {
        return `#!/usr/bin/env python3
    # -*- coding: utf-8 -*-

    import sys
    import builtins
    import io
    import json
    import traceback
    import codecs
    import locale
    from contextlib import redirect_stdout, redirect_stderr

    # ========== UTF-8ç¼–ç é…ç½® ==========

    # ç¡®ä¿UTF-8ç¼–ç å¤„ç†
    if hasattr(sys.stdout, 'buffer'):
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)
    if hasattr(sys.stderr, 'buffer'):
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer)

    # è®¾ç½®é»˜è®¤ç¼–ç 
    if hasattr(sys, 'setdefaultencoding'):
        sys.setdefaultencoding('utf-8')

    # ========== å®‰å…¨é…ç½® ==========

    # ä¿å­˜å¿…è¦çš„å†…ç½®å‡½æ•°ç”¨äºå†…éƒ¨æ“ä½œ
    _internal_open = builtins.open
    _internal_exec = builtins.exec
    _internal_eval = builtins.eval
    _internal_compile = builtins.compile

    # å®‰å…¨çš„æ¨¡å—å¯¼å…¥æ§åˆ¶
    original_import = builtins.__import__

    def safe_import(name, *args, **kwargs):
        """å®‰å…¨æ¨¡å—å¯¼å…¥ï¼Œé»‘åå•ç­–ç•¥"""
        
        # é»‘åå•ï¼šå±é™©çš„ç³»ç»Ÿæ¨¡å—
        dangerous_modules = {
            'os', 'subprocess', 'socket', 'urllib', 'http', 'requests',
            'ftplib', 'poplib', 'imaplib', 'smtplib', 'telnetlib', 'webbrowser',
            'pickle', 'marshal', 'shelve', 'dbm', 'sqlite3',
            'threading', 'multiprocessing',
            'ctypes', 'gc', 'signal', 'resource', 'mmap', 'fcntl',
            'termios', 'tty', 'pty', 'grp', 'pwd', 'spwd', 'crypt',
            'importlib', 'pkgutil', 'runpy', 'zipimport', 'inspect', 
            'types', 'code', 'codeop', 'compileall', 'dis',
            'atexit', 'ssl', 'hashlib', 'hmac', 'secrets'
        }
        
        if name in dangerous_modules:
            raise ImportError(f"ğŸš« SECURITY: Dangerous module '{name}' is blocked")
        
        # å…è®¸æ‰€æœ‰éå±é™©æ¨¡å—
        return original_import(name, *args, **kwargs)

    # ========== è¾“å‡ºæ•è· ==========

    # å…¨å±€å˜é‡ç”¨äºæ•è· return_val
    _return_val_output = None

    def return_val(value):
        """æ•è·è¿”å›å€¼ï¼Œä½¿ç”¨æ›´æ¸…æ™°çš„åˆ†éš”ç¬¦"""
        global _return_val_output
        _return_val_output = str(value) if value is not None else ""
        # ä½¿ç”¨ç‰¹æ®Šçš„åˆ†éš”ç¬¦ï¼Œé¿å…ä¸æ­£å¸¸è¾“å‡ºæ··æ·†
        print(f"__COZE_RETURN_VAL_START__")
        print(_return_val_output)
        print(f"__COZE_RETURN_VAL_END__")

    # åˆ›å»ºå—é™çš„ç”¨æˆ·å‘½åç©ºé—´
    def create_safe_builtins():
        """åˆ›å»ºå®‰å…¨çš„å†…ç½®å‡½æ•°é›†åˆï¼Œç§»é™¤å±é™©å‡½æ•°"""
        safe_builtins = {}
        
        # å¤åˆ¶æ‰€æœ‰å®‰å…¨çš„å†…ç½®å‡½æ•°
        for name, obj in builtins.__dict__.items():
            if name not in ['open', 'input', 'raw_input', 'file', 'execfile', 'reload', 'compile', 'eval', 'exec']:
                safe_builtins[name] = obj
        
        # æ·»åŠ è‡ªå®šä¹‰å‡½æ•°
        safe_builtins['return_val'] = return_val
        
        return safe_builtins

    # åˆ›å»ºç”¨æˆ·ä»£ç çš„å®‰å…¨æ‰§è¡Œç¯å¢ƒ
    user_globals = {
        '__builtins__': create_safe_builtins(),
        '__import__': safe_import,
        'json': json
    }

    # ========== æ‰§è¡Œç”¨æˆ·ä»£ç  ==========

    try:
        # æ•è· stdout å’Œ stderr
        stdout_capture = io.StringIO()
        stderr_capture = io.StringIO()
        
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            # è¯»å–å¹¶æ‰§è¡Œç”¨æˆ·ä»£ç æ–‡ä»¶
            with _internal_open('${userCodeFile}', 'r', encoding='utf-8') as f:
                user_code = f.read()
            _internal_exec(user_code, user_globals)
        
        # è¾“å‡ºç»“æœ
        stdout_content = stdout_capture.getvalue()
        stderr_content = stderr_capture.getvalue()
        
        # è¾“å‡ºåˆ°çœŸæ­£çš„ stdoutï¼ˆç¡®ä¿UTF-8ç¼–ç ï¼‰
        if stdout_content:
            try:
                sys.stdout.write(stdout_content)
                sys.stdout.flush()
            except UnicodeEncodeError:
                # å¦‚æœæœ‰ç¼–ç é—®é¢˜ï¼Œå¼ºåˆ¶ä½¿ç”¨UTF-8
                sys.stdout.buffer.write(stdout_content.encode('utf-8'))
                sys.stdout.buffer.flush()
        
        # è¾“å‡ºåˆ°çœŸæ­£çš„ stderrï¼ˆç¡®ä¿UTF-8ç¼–ç ï¼‰
        if stderr_content:
            try:
                sys.stderr.write(stderr_content)
                sys.stderr.flush()
            except UnicodeEncodeError:
                # å¦‚æœæœ‰ç¼–ç é—®é¢˜ï¼Œå¼ºåˆ¶ä½¿ç”¨UTF-8
                sys.stderr.buffer.write(stderr_content.encode('utf-8'))
                sys.stderr.buffer.flush()
            
    except Exception as e:
        error_msg = traceback.format_exc()
        try:
            print(error_msg, file=sys.stderr)
        except UnicodeEncodeError:
            # å¦‚æœæœ‰ç¼–ç é—®é¢˜ï¼Œå¼ºåˆ¶ä½¿ç”¨UTF-8
            sys.stderr.buffer.write(error_msg.encode('utf-8'))
            sys.stderr.buffer.flush()
        sys.exit(1)
    `;
      }

      /**
       * æå– return_val çš„ç»“æœï¼Œä½¿ç”¨æ›´å¥å£®çš„æå–é€»è¾‘
       */
      private extractReturnValue(stdout: string): string {
        const match = stdout.match(/__COZE_RETURN_VAL_START__\n(.*?)\n__COZE_RETURN_VAL_END__/s);
        return match ? match[1] : "";
      }

      /**
       * æ¸…ç† stdoutï¼Œç§»é™¤ return_val è¾“å‡º
       */
      private cleanStdout(stdout: string): string {
        // ç§»é™¤å®Œæ•´çš„return_valè¾“å‡ºå—
        return stdout.replace(/__COZE_RETURN_VAL_START__\n.*?\n__COZE_RETURN_VAL_END__\n?/gs, '');
      }

      getPythonVersion(): string | null {
        return this.pythonVersion;
      }

      getExecutionCount(): number {
        return this.executionCount;
      }
    }

    // ==================== å¢å¼º FaaS æœåŠ¡å™¨ ====================

    class EnhancedPythonFaaSServer {
      private readonly executor: EnhancedPythonExecutor;
      private readonly startTime = Date.now();

      constructor() {
        this.executor = new EnhancedPythonExecutor();
      }

      /**
       * å¤„ç†ä»£ç æ‰§è¡Œè¯·æ±‚
       */
      async handleRunCode(request: Request): Promise<Response> {
        try {
          // å¢å¼ºJSONè¯·æ±‚å¤„ç†
          let body;
          try {
            body = await request.json();
          } catch (jsonError) {
            console.error("JSONè§£æé”™è¯¯:", jsonError);
            return new Response(
              JSON.stringify({ 
                error: "Invalid JSON format", 
                details: jsonError instanceof Error ? jsonError.message : String(jsonError)
              }),
              { status: 400, headers: { "Content-Type": "application/json" } }
            );
          }

          const { language, code, timeout = 30000 } = body;

          if (!code) {
            return new Response(
              JSON.stringify({ error: "Missing required parameter: code" }),
              { status: 400, headers: { "Content-Type": "application/json" } }
            );
          }

          if (typeof code !== 'string') {
            return new Response(
              JSON.stringify({ error: "Parameter 'code' must be a string" }),
              { status: 400, headers: { "Content-Type": "application/json" } }
            );
          }

          // è¯­è¨€æ£€æŸ¥ï¼ˆå¯é€‰ï¼Œå› ä¸ºæœåŠ¡ä¸“é—¨å¤„ç†Pythonï¼‰
          if (language && !["python", "py"].includes(language.toLowerCase())) {
            return new Response(
              JSON.stringify({ error: "This service only supports Python code execution" }),
              { status: 400, headers: { "Content-Type": "application/json" } }
            );
          }

          console.log(`ğŸ“ æ‰§è¡ŒPythonä»£ç ï¼Œé•¿åº¦: ${code.length}å­—ç¬¦ï¼Œè¶…æ—¶: ${timeout}ms`);

          const startTime = Date.now();
          const result = await this.executor.executePython(code, timeout);
          const duration = Date.now() - startTime;

          const response = {
            output: {
              stdout: result.stdout,
              stderr: result.stderr,
              ret_val: result.returnValue
            },
            metadata: {
              language: "python",
              runtime: "enhanced-real-executor",
              duration,
              status: result.metadata.exitCode === 0 ? "success" : "error",
              exit_code: result.metadata.exitCode,
              timed_out: result.metadata.timedOut
            }
          };

          console.log(`âœ… æ‰§è¡Œå®Œæˆï¼Œè€—æ—¶: ${duration}msï¼Œé€€å‡ºç : ${result.metadata.exitCode}`);

          return new Response(JSON.stringify(response), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });

        } catch (error) {
          console.error("âŒ å¤„ç†run_codeè¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯:", error);
          const errorMessage = error instanceof Error ? error.message : String(error);

          // åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
          let statusCode = 500;
          let errorType = "Execution failed";

          if (error instanceof SyntaxError) {
            statusCode = 400;
            errorType = "JSON parsing error";
          } else if (errorMessage.includes('timeout')) {
            statusCode = 408;
            errorType = "Execution timeout";
          }

          return new Response(
            JSON.stringify({ 
              error: errorType, 
              details: errorMessage 
            }),
            { status: statusCode, headers: { "Content-Type": "application/json" } }
          );
        }
      }

      /**
       * å¤„ç†å¥åº·æ£€æŸ¥
       */
      handleHealth(): Response {
        const healthData: HealthStatus = {
          status: "healthy",
          timestamp: new Date().toISOString(),
          runtime: "deno-enhanced-real-executor",
          version: "enhanced-python-faas-v1.0.0",
          execution_count: this.executor.getExecutionCount(),
          python_version: this.executor.getPythonVersion() || undefined,
          security: {
            sandbox: "deno-permissions+docker-isolation",
            isolation: "process-level+container-level",
            permissions: "restricted"
          }
        };

        return new Response(JSON.stringify(healthData), {
          status: 200,
          headers: { "Content-Type": "application/json" }
        });
      }

      /**
       * å¤„ç†æŒ‡æ ‡è¯·æ±‚
       */
      handleMetrics(): Response {
        const uptime = Date.now() - this.startTime;
        const metrics = {
          execution_count: this.executor.getExecutionCount(),
          uptime_seconds: Math.floor(uptime / 1000),
          runtime: "enhanced-real-executor",
          python_version: this.executor.getPythonVersion(),
          status: "healthy"
        };

        return new Response(JSON.stringify(metrics), {
          status: 200,
          headers: { "Content-Type": "application/json" }
        });
      }
    }

    // ==================== ä¸»å‡½æ•° ====================

    async function main() {
      const port = parseInt(Deno.env.get("FAAS_PORT") || "8000");

      console.log(`ğŸš€ å¯åŠ¨å¢å¼ºç‰ˆ Python FaaS æœåŠ¡å™¨ï¼Œç«¯å£: ${port}...`);
      console.log("ğŸ”’ å®‰å…¨ç‰¹æ€§: Deno æƒé™æ§åˆ¶ + Docker å®¹å™¨éš”ç¦» + ä»£ç å®‰å…¨æ£€æŸ¥");
      console.log("âš¡ è¿è¡Œæ¨¡å¼: çœŸå® Python æ‰§è¡Œå™¨ (æ”¯æŒå®Œæ•´ Python åŠŸèƒ½)");

      const faasServer = new EnhancedPythonFaaSServer();

      const handler = async (request: Request): Promise<Response> => {
        const url = new URL(request.url);
        const method = request.method;

        console.log(`${method} ${url.pathname}`);

        // è·¯ç”±å¤„ç†
        switch (url.pathname) {
          case "/health":
            return faasServer.handleHealth();
          
          case "/metrics":
            return faasServer.handleMetrics();
          
          case "/run_code":
            if (method === "POST") {
              return await faasServer.handleRunCode(request);
            }
            break;
        }

        return new Response("Not Found", { status: 404 });
      };

      // å¯åŠ¨æœåŠ¡å™¨
      Deno.serve({
        port,
        hostname: "0.0.0.0"
      }, handler);

      console.log(`âœ… å¢å¼ºç‰ˆ Python FaaS æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ: http://0.0.0.0:${port}`);
      console.log("ğŸ“¡ å¯ç”¨ç«¯ç‚¹:");
      console.log("  GET  /health    - å¥åº·æ£€æŸ¥");
      console.log("  GET  /metrics   - æŒ‡æ ‡ä¿¡æ¯");
      console.log("  POST /run_code  - æ‰§è¡Œ Python ä»£ç  (çœŸå®æ‰§è¡Œ)");
      console.log("");
      console.log("ğŸ” å®‰å…¨ä¿éšœ:");
      console.log("  âœ… Deno æƒé™æ§åˆ¶");
      console.log("  âœ… Docker å®¹å™¨éš”ç¦»");
      console.log("  âœ… å±é™©ä»£ç æ£€æµ‹");
      console.log("  âœ… å±é™©ç³»ç»Ÿæ¨¡å—é»‘åå•");
      console.log("  âœ… å…è®¸éç³»ç»Ÿæ¨¡å—å¯¼å…¥");
      console.log("  âœ… ä¸´æ—¶æ–‡ä»¶éš”ç¦»");
      console.log("  âœ… ç¯å¢ƒå˜é‡æ§åˆ¶");
      console.log("");
      console.log("âš¡ ç‰¹æ€§:");
      console.log("  âœ… çœŸæ­£çš„ Python ä»£ç æ‰§è¡Œ");
      console.log("  âœ… æ”¯æŒå‡½æ•°å®šä¹‰å’Œè°ƒç”¨");
      console.log("  âœ… æ”¯æŒå¤æ‚æ•°æ®å¤„ç†");
      console.log("  âœ… æ”¯æŒè‡ªå®šä¹‰å¯¹è±¡å’Œç±»");
      console.log("  âœ… å®Œæ•´çš„ stdout/stderr æ•è·");
      console.log("  âœ… return_val å‡½æ•°æ”¯æŒ");
      console.log("  âœ… æ‰§è¡Œè¶…æ—¶æ§åˆ¶");
      console.log("  âœ… API å…¼å®¹æ€§");
    }

    if (import.meta.main) {
      await main();
    }