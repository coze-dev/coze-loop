// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/infra/redis (interfaces: PersistentCmdable)
//
// Generated by this command:
//
//	mockgen -destination=mocks/persist_redis.go -package=mocks . PersistentCmdable
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	redis "github.com/coze-dev/coze-loop/backend/infra/redis"
	redis0 "github.com/redis/go-redis/v9"
	gomock "go.uber.org/mock/gomock"
)

// MockPersistentCmdable is a mock of PersistentCmdable interface.
type MockPersistentCmdable struct {
	ctrl     *gomock.Controller
	recorder *MockPersistentCmdableMockRecorder
	isgomock struct{}
}

// MockPersistentCmdableMockRecorder is the mock recorder for MockPersistentCmdable.
type MockPersistentCmdableMockRecorder struct {
	mock *MockPersistentCmdable
}

// NewMockPersistentCmdable creates a new mock instance.
func NewMockPersistentCmdable(ctrl *gomock.Controller) *MockPersistentCmdable {
	mock := &MockPersistentCmdable{ctrl: ctrl}
	mock.recorder = &MockPersistentCmdableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPersistentCmdable) EXPECT() *MockPersistentCmdableMockRecorder {
	return m.recorder
}

// Decr mocks base method.
func (m *MockPersistentCmdable) Decr(ctx context.Context, key string) *redis0.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Decr", ctx, key)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// Decr indicates an expected call of Decr.
func (mr *MockPersistentCmdableMockRecorder) Decr(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decr", reflect.TypeOf((*MockPersistentCmdable)(nil).Decr), ctx, key)
}

// DecrBy mocks base method.
func (m *MockPersistentCmdable) DecrBy(ctx context.Context, key string, decrement int64) *redis0.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DecrBy", ctx, key, decrement)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// DecrBy indicates an expected call of DecrBy.
func (mr *MockPersistentCmdableMockRecorder) DecrBy(ctx, key, decrement any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DecrBy", reflect.TypeOf((*MockPersistentCmdable)(nil).DecrBy), ctx, key, decrement)
}

// Del mocks base method.
func (m *MockPersistentCmdable) Del(ctx context.Context, keys ...string) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Del", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// Del indicates an expected call of Del.
func (mr *MockPersistentCmdableMockRecorder) Del(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockPersistentCmdable)(nil).Del), varargs...)
}

// Eval mocks base method.
func (m *MockPersistentCmdable) Eval(ctx context.Context, script string, keys []string, args ...any) *redis0.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, script, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Eval", varargs...)
	ret0, _ := ret[0].(*redis0.Cmd)
	return ret0
}

// Eval indicates an expected call of Eval.
func (mr *MockPersistentCmdableMockRecorder) Eval(ctx, script, keys any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, script, keys}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eval", reflect.TypeOf((*MockPersistentCmdable)(nil).Eval), varargs...)
}

// Exists mocks base method.
func (m *MockPersistentCmdable) Exists(ctx context.Context, keys ...string) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exists", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockPersistentCmdableMockRecorder) Exists(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockPersistentCmdable)(nil).Exists), varargs...)
}

// Expire mocks base method.
func (m *MockPersistentCmdable) Expire(ctx context.Context, key string, expiration time.Duration) *redis0.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Expire", ctx, key, expiration)
	ret0, _ := ret[0].(*redis0.BoolCmd)
	return ret0
}

// Expire indicates an expected call of Expire.
func (mr *MockPersistentCmdableMockRecorder) Expire(ctx, key, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Expire", reflect.TypeOf((*MockPersistentCmdable)(nil).Expire), ctx, key, expiration)
}

// Get mocks base method.
func (m *MockPersistentCmdable) Get(ctx context.Context, key string) *redis0.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(*redis0.StringCmd)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockPersistentCmdableMockRecorder) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPersistentCmdable)(nil).Get), ctx, key)
}

// HDel mocks base method.
func (m *MockPersistentCmdable) HDel(ctx context.Context, key string, fields ...string) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HDel", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// HDel indicates an expected call of HDel.
func (mr *MockPersistentCmdableMockRecorder) HDel(ctx, key any, fields ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HDel", reflect.TypeOf((*MockPersistentCmdable)(nil).HDel), varargs...)
}

// HExists mocks base method.
func (m *MockPersistentCmdable) HExists(ctx context.Context, key, field string) *redis0.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HExists", ctx, key, field)
	ret0, _ := ret[0].(*redis0.BoolCmd)
	return ret0
}

// HExists indicates an expected call of HExists.
func (mr *MockPersistentCmdableMockRecorder) HExists(ctx, key, field any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExists", reflect.TypeOf((*MockPersistentCmdable)(nil).HExists), ctx, key, field)
}

// HGet mocks base method.
func (m *MockPersistentCmdable) HGet(ctx context.Context, key, field string) *redis0.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HGet", ctx, key, field)
	ret0, _ := ret[0].(*redis0.StringCmd)
	return ret0
}

// HGet indicates an expected call of HGet.
func (mr *MockPersistentCmdableMockRecorder) HGet(ctx, key, field any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGet", reflect.TypeOf((*MockPersistentCmdable)(nil).HGet), ctx, key, field)
}

// HGetAll mocks base method.
func (m *MockPersistentCmdable) HGetAll(ctx context.Context, key string) *redis0.MapStringStringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HGetAll", ctx, key)
	ret0, _ := ret[0].(*redis0.MapStringStringCmd)
	return ret0
}

// HGetAll indicates an expected call of HGetAll.
func (mr *MockPersistentCmdableMockRecorder) HGetAll(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGetAll", reflect.TypeOf((*MockPersistentCmdable)(nil).HGetAll), ctx, key)
}

// HIncrBy mocks base method.
func (m *MockPersistentCmdable) HIncrBy(ctx context.Context, key, field string, incr int64) *redis0.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HIncrBy", ctx, key, field, incr)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// HIncrBy indicates an expected call of HIncrBy.
func (mr *MockPersistentCmdableMockRecorder) HIncrBy(ctx, key, field, incr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HIncrBy", reflect.TypeOf((*MockPersistentCmdable)(nil).HIncrBy), ctx, key, field, incr)
}

// HKeys mocks base method.
func (m *MockPersistentCmdable) HKeys(ctx context.Context, key string) *redis0.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HKeys", ctx, key)
	ret0, _ := ret[0].(*redis0.StringSliceCmd)
	return ret0
}

// HKeys indicates an expected call of HKeys.
func (mr *MockPersistentCmdableMockRecorder) HKeys(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HKeys", reflect.TypeOf((*MockPersistentCmdable)(nil).HKeys), ctx, key)
}

// HLen mocks base method.
func (m *MockPersistentCmdable) HLen(ctx context.Context, key string) *redis0.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HLen", ctx, key)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// HLen indicates an expected call of HLen.
func (mr *MockPersistentCmdableMockRecorder) HLen(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HLen", reflect.TypeOf((*MockPersistentCmdable)(nil).HLen), ctx, key)
}

// HMGet mocks base method.
func (m *MockPersistentCmdable) HMGet(ctx context.Context, key string, fields ...string) *redis0.SliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HMGet", varargs...)
	ret0, _ := ret[0].(*redis0.SliceCmd)
	return ret0
}

// HMGet indicates an expected call of HMGet.
func (mr *MockPersistentCmdableMockRecorder) HMGet(ctx, key any, fields ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HMGet", reflect.TypeOf((*MockPersistentCmdable)(nil).HMGet), varargs...)
}

// HSet mocks base method.
func (m *MockPersistentCmdable) HSet(ctx context.Context, key string, values ...any) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HSet", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// HSet indicates an expected call of HSet.
func (mr *MockPersistentCmdableMockRecorder) HSet(ctx, key any, values ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HSet", reflect.TypeOf((*MockPersistentCmdable)(nil).HSet), varargs...)
}

// HSetNX mocks base method.
func (m *MockPersistentCmdable) HSetNX(ctx context.Context, key, field string, value any) *redis0.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HSetNX", ctx, key, field, value)
	ret0, _ := ret[0].(*redis0.BoolCmd)
	return ret0
}

// HSetNX indicates an expected call of HSetNX.
func (mr *MockPersistentCmdableMockRecorder) HSetNX(ctx, key, field, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HSetNX", reflect.TypeOf((*MockPersistentCmdable)(nil).HSetNX), ctx, key, field, value)
}

// Incr mocks base method.
func (m *MockPersistentCmdable) Incr(ctx context.Context, key string) *redis0.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Incr", ctx, key)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// Incr indicates an expected call of Incr.
func (mr *MockPersistentCmdableMockRecorder) Incr(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockPersistentCmdable)(nil).Incr), ctx, key)
}

// IncrBy mocks base method.
func (m *MockPersistentCmdable) IncrBy(ctx context.Context, key string, value int64) *redis0.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrBy", ctx, key, value)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// IncrBy indicates an expected call of IncrBy.
func (mr *MockPersistentCmdableMockRecorder) IncrBy(ctx, key, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrBy", reflect.TypeOf((*MockPersistentCmdable)(nil).IncrBy), ctx, key, value)
}

// MGet mocks base method.
func (m *MockPersistentCmdable) MGet(ctx context.Context, keys ...string) *redis0.SliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGet", varargs...)
	ret0, _ := ret[0].(*redis0.SliceCmd)
	return ret0
}

// MGet indicates an expected call of MGet.
func (mr *MockPersistentCmdableMockRecorder) MGet(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockPersistentCmdable)(nil).MGet), varargs...)
}

// MSet mocks base method.
func (m *MockPersistentCmdable) MSet(ctx context.Context, values ...any) *redis0.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSet", varargs...)
	ret0, _ := ret[0].(*redis0.StatusCmd)
	return ret0
}

// MSet indicates an expected call of MSet.
func (mr *MockPersistentCmdableMockRecorder) MSet(ctx any, values ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockPersistentCmdable)(nil).MSet), varargs...)
}

// MSetNX mocks base method.
func (m *MockPersistentCmdable) MSetNX(ctx context.Context, values ...any) *redis0.BoolCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSetNX", varargs...)
	ret0, _ := ret[0].(*redis0.BoolCmd)
	return ret0
}

// MSetNX indicates an expected call of MSetNX.
func (mr *MockPersistentCmdableMockRecorder) MSetNX(ctx any, values ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSetNX", reflect.TypeOf((*MockPersistentCmdable)(nil).MSetNX), varargs...)
}

// Pipeline mocks base method.
func (m *MockPersistentCmdable) Pipeline() redis.Pipeliner {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pipeline")
	ret0, _ := ret[0].(redis.Pipeliner)
	return ret0
}

// Pipeline indicates an expected call of Pipeline.
func (mr *MockPersistentCmdableMockRecorder) Pipeline() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pipeline", reflect.TypeOf((*MockPersistentCmdable)(nil).Pipeline))
}

// RPush mocks base method.
func (m *MockPersistentCmdable) RPush(ctx context.Context, key string, values ...any) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RPush", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// RPush indicates an expected call of RPush.
func (mr *MockPersistentCmdableMockRecorder) RPush(ctx, key any, values ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPush", reflect.TypeOf((*MockPersistentCmdable)(nil).RPush), varargs...)
}

// Set mocks base method.
func (m *MockPersistentCmdable) Set(ctx context.Context, key string, value any, expiration time.Duration) *redis0.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis0.StatusCmd)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockPersistentCmdableMockRecorder) Set(ctx, key, value, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockPersistentCmdable)(nil).Set), ctx, key, value, expiration)
}

// SetNX mocks base method.
func (m *MockPersistentCmdable) SetNX(ctx context.Context, key string, value any, expiration time.Duration) *redis0.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetNX", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis0.BoolCmd)
	return ret0
}

// SetNX indicates an expected call of SetNX.
func (mr *MockPersistentCmdableMockRecorder) SetNX(ctx, key, value, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNX", reflect.TypeOf((*MockPersistentCmdable)(nil).SetNX), ctx, key, value, expiration)
}

// ZAdd mocks base method.
func (m *MockPersistentCmdable) ZAdd(ctx context.Context, key string, members ...redis0.Z) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAdd", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// ZAdd indicates an expected call of ZAdd.
func (mr *MockPersistentCmdableMockRecorder) ZAdd(ctx, key any, members ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAdd", reflect.TypeOf((*MockPersistentCmdable)(nil).ZAdd), varargs...)
}

// ZAddNX mocks base method.
func (m *MockPersistentCmdable) ZAddNX(ctx context.Context, key string, members ...redis0.Z) *redis0.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAddNX", varargs...)
	ret0, _ := ret[0].(*redis0.IntCmd)
	return ret0
}

// ZAddNX indicates an expected call of ZAddNX.
func (mr *MockPersistentCmdableMockRecorder) ZAddNX(ctx, key any, members ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddNX", reflect.TypeOf((*MockPersistentCmdable)(nil).ZAddNX), varargs...)
}

// ZRange mocks base method.
func (m *MockPersistentCmdable) ZRange(ctx context.Context, key string, start, stop int64) *redis0.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRange", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis0.StringSliceCmd)
	return ret0
}

// ZRange indicates an expected call of ZRange.
func (mr *MockPersistentCmdableMockRecorder) ZRange(ctx, key, start, stop any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRange", reflect.TypeOf((*MockPersistentCmdable)(nil).ZRange), ctx, key, start, stop)
}
