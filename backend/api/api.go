// Copyright (c) 2025 coze-dev Authors
// SPDX-License-Identifier: Apache-2.0

// Code generated by hertz generator.

package api

import (
	"context"

	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/app/server/binding"
	"github.com/cloudwego/hertz/pkg/app/server/render"

	"github.com/coze-dev/coze-loop/backend/api/handler/coze/loop/apis"
	"github.com/coze-dev/coze-loop/backend/infra/ck"
	"github.com/coze-dev/coze-loop/backend/infra/db"
	"github.com/coze-dev/coze-loop/backend/infra/external/audit"
	"github.com/coze-dev/coze-loop/backend/infra/external/benefit"
	"github.com/coze-dev/coze-loop/backend/infra/fileserver"
	"github.com/coze-dev/coze-loop/backend/infra/i18n"
	"github.com/coze-dev/coze-loop/backend/infra/idgen"
	"github.com/coze-dev/coze-loop/backend/infra/limiter"
	"github.com/coze-dev/coze-loop/backend/infra/metrics"
	"github.com/coze-dev/coze-loop/backend/infra/middleware/validator"
	"github.com/coze-dev/coze-loop/backend/infra/mq"
	"github.com/coze-dev/coze-loop/backend/infra/redis"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/observability/observabilitytraceservice"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/observability/task/taskservice"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/data/lodataset"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/data/lotag"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/evaluation/loeval_set"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/evaluation/loevaluator"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/evaluation/loexpt"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/foundation/loauth"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/foundation/lofile"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/foundation/louser"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/llm/loruntime"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/observability/lotask"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/observability/lotrace"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/prompt/loexecute"
	"github.com/coze-dev/coze-loop/backend/loop_gen/coze/loop/prompt/lomanage"
	"github.com/coze-dev/coze-loop/backend/modules/observability/domain/task/service/taskexe/processor"
	"github.com/coze-dev/coze-loop/backend/modules/observability/infra/storage"
	"github.com/coze-dev/coze-loop/backend/pkg/conf"
	"github.com/coze-dev/coze-loop/backend/pkg/lang/js_conv"
)

func Init(
	ctx context.Context,
	idgen idgen.IIDGenerator,
	db db.Provider,
	cmdable redis.Cmdable,
	persistentCmdable redis.PersistentCmdable,
	configFactory conf.IConfigLoaderFactory,
	mqFactory mq.IFactory,
	objectStorage fileserver.ObjectStorage,
	batchObjectStorage fileserver.BatchObjectStorage,
	benefitSvc benefit.IBenefitService,
	auditClient audit.IAuditService,
	meter metrics.Meter,
	limiterFactory limiter.IRateLimiterFactory,
	ckDB ck.Provider,
	translater i18n.ITranslater,
	plainLimiterFactory limiter.IPlainRateLimiterFactory,
) (*apis.APIHandler, error) {
	foundationHandler, err := apis.InitFoundationHandler(idgen, db, batchObjectStorage, configFactory)
	if err != nil {
		return nil, err
	}

	llmHandler, err := apis.InitLLMHandler(ctx, idgen, db, cmdable, configFactory, limiterFactory, loauth.NewLocalAuthService(foundationHandler.AuthService))
	if err != nil {
		return nil, err
	}

	promptHandler, err := apis.InitPromptHandler(ctx, idgen, db, cmdable, meter, configFactory, limiterFactory, benefitSvc,
		loruntime.NewLocalLLMRuntimeService(llmHandler.LLMRuntimeService),
		loauth.NewLocalAuthService(foundationHandler.AuthService),
		lofile.NewLocalFileService(foundationHandler.FileService),
		louser.NewLocalUserService(foundationHandler.UserService),
		auditClient,
	)
	if err != nil {
		return nil, err
	}

	dataHandler, err := apis.InitDataHandler(ctx, idgen, db, cmdable, configFactory, mqFactory,
		objectStorage, batchObjectStorage, auditClient,
		loauth.NewLocalAuthService(foundationHandler.AuthService),
		louser.NewLocalUserService(foundationHandler.UserService),
	)
	if err != nil {
		return nil, err
	}

	var (
		observabilityHandler *apis.ObservabilityHandler
		evaluationHandler    *apis.EvaluationHandler
	)

	evaluationHandler, err = apis.InitEvaluationHandler(
		ctx, idgen, db, ckDB, cmdable, configFactory, mqFactory,
		lodataset.NewLocalDatasetService(dataHandler.IDatasetApplication, validator.KiteXValidatorMW),
		lomanage.NewLocalPromptManageService(promptHandler.PromptManageService),
		loexecute.NewLocalPromptExecuteService(promptHandler.PromptExecuteService),
		loauth.NewLocalAuthService(foundationHandler.AuthService),
		meter,
		auditClient,
		loruntime.NewLocalLLMRuntimeService(llmHandler.LLMRuntimeService),
		louser.NewLocalUserService(foundationHandler.UserService),
		benefitSvc,
		limiterFactory,
		lofile.NewLocalFileService(foundationHandler.FileService),
		lotag.NewLocalTagService(dataHandler.TagService),
		objectStorage,
		plainLimiterFactory,
		func() observabilitytraceservice.Client {
			return lotrace.NewLocalTraceService(observabilityHandler.ITraceApplication)
		},
		func() taskservice.Client {
			return lotask.NewLocalTaskService(observabilityHandler.ITaskApplication)
		},
	)
	if err != nil {
		return nil, err
	}

	observabilityHandler, err = apis.InitObservabilityHandler(ctx, db, ckDB, meter, mqFactory, configFactory, idgen,
		benefitSvc,
		lofile.NewLocalFileService(foundationHandler.FileService),
		loauth.NewLocalAuthService(foundationHandler.AuthService),
		louser.NewLocalUserService(foundationHandler.UserService),
		loevaluator.NewLocalEvaluatorService(evaluationHandler.EvaluatorService),
		loeval_set.NewLocalEvaluationSetService(evaluationHandler.EvaluationSetService),
		lotag.NewLocalTagService(dataHandler.TagService),
		limiterFactory,
		lodataset.NewLocalDatasetService(dataHandler.IDatasetApplication),
		cmdable,
		persistentCmdable,
		storage.NewTraceStorageProvider(),
		loexpt.NewLocalExperimentService(evaluationHandler.IExperimentApplication),
		processor.TaskProcessor{},
		0,
	)
	if err != nil {
		return nil, err
	}
	if err = observabilityHandler.RunTaskScheduleTask(ctx); err != nil {
		return nil, err
	}
	observabilityHandler.RunAsync(ctx)

	return &apis.APIHandler{
		PromptHandler:        promptHandler,
		LLMHandler:           llmHandler,
		EvaluationHandler:    evaluationHandler,
		DataHandler:          dataHandler,
		ObservabilityHandler: observabilityHandler,
		FoundationHandler:    foundationHandler,
		Translater:           translater,
	}, nil
}

func Start(handler *apis.APIHandler) {
	render.ResetJSONMarshal(js_conv.GetMarshaler())

	bindConfig := binding.NewBindConfig()
	bindConfig.UseThirdPartyJSONUnmarshaler(js_conv.GetUnmarshaler())

	h := server.Default(server.WithBindConfig(bindConfig), server.WithMaxRequestBodySize(20*1024*1024))

	register(h, handler)

	h.Spin()
}
