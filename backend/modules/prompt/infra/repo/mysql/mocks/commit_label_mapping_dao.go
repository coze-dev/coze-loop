// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/prompt/infra/repo/mysql (interfaces: ICommitLabelMappingDAO)
//
// Generated by this command:
//
//	mockgen -destination=mocks/commit_label_mapping_dao.go -package=mocks . ICommitLabelMappingDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	mysql "github.com/coze-dev/coze-loop/backend/modules/prompt/infra/repo/mysql"
	model "github.com/coze-dev/coze-loop/backend/modules/prompt/infra/repo/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockICommitLabelMappingDAO is a mock of ICommitLabelMappingDAO interface.
type MockICommitLabelMappingDAO struct {
	ctrl     *gomock.Controller
	recorder *MockICommitLabelMappingDAOMockRecorder
	isgomock struct{}
}

// MockICommitLabelMappingDAOMockRecorder is the mock recorder for MockICommitLabelMappingDAO.
type MockICommitLabelMappingDAOMockRecorder struct {
	mock *MockICommitLabelMappingDAO
}

// NewMockICommitLabelMappingDAO creates a new mock instance.
func NewMockICommitLabelMappingDAO(ctrl *gomock.Controller) *MockICommitLabelMappingDAO {
	mock := &MockICommitLabelMappingDAO{ctrl: ctrl}
	mock.recorder = &MockICommitLabelMappingDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICommitLabelMappingDAO) EXPECT() *MockICommitLabelMappingDAOMockRecorder {
	return m.recorder
}

// BatchCreate mocks base method.
func (m *MockICommitLabelMappingDAO) BatchCreate(ctx context.Context, mappings []*model.PromptCommitLabelMapping, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, mappings}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchCreate indicates an expected call of BatchCreate.
func (mr *MockICommitLabelMappingDAOMockRecorder) BatchCreate(ctx, mappings any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, mappings}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreate", reflect.TypeOf((*MockICommitLabelMappingDAO)(nil).BatchCreate), varargs...)
}

// BatchDelete mocks base method.
func (m *MockICommitLabelMappingDAO) BatchDelete(ctx context.Context, ids []int64, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, ids}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDelete", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchDelete indicates an expected call of BatchDelete.
func (mr *MockICommitLabelMappingDAOMockRecorder) BatchDelete(ctx, ids any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, ids}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDelete", reflect.TypeOf((*MockICommitLabelMappingDAO)(nil).BatchDelete), varargs...)
}

// BatchUpdate mocks base method.
func (m *MockICommitLabelMappingDAO) BatchUpdate(ctx context.Context, mappings []*model.PromptCommitLabelMapping, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, mappings}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchUpdate indicates an expected call of BatchUpdate.
func (mr *MockICommitLabelMappingDAOMockRecorder) BatchUpdate(ctx, mappings any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, mappings}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchUpdate", reflect.TypeOf((*MockICommitLabelMappingDAO)(nil).BatchUpdate), varargs...)
}

// ListByPromptIDAndLabelKeys mocks base method.
func (m *MockICommitLabelMappingDAO) ListByPromptIDAndLabelKeys(ctx context.Context, promptID int64, labelKeys []string, opts ...db.Option) ([]*model.PromptCommitLabelMapping, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, promptID, labelKeys}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListByPromptIDAndLabelKeys", varargs...)
	ret0, _ := ret[0].([]*model.PromptCommitLabelMapping)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListByPromptIDAndLabelKeys indicates an expected call of ListByPromptIDAndLabelKeys.
func (mr *MockICommitLabelMappingDAOMockRecorder) ListByPromptIDAndLabelKeys(ctx, promptID, labelKeys any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, promptID, labelKeys}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByPromptIDAndLabelKeys", reflect.TypeOf((*MockICommitLabelMappingDAO)(nil).ListByPromptIDAndLabelKeys), varargs...)
}

// ListByPromptIDAndVersions mocks base method.
func (m *MockICommitLabelMappingDAO) ListByPromptIDAndVersions(ctx context.Context, promptID int64, versions []string, opts ...db.Option) ([]*model.PromptCommitLabelMapping, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, promptID, versions}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListByPromptIDAndVersions", varargs...)
	ret0, _ := ret[0].([]*model.PromptCommitLabelMapping)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListByPromptIDAndVersions indicates an expected call of ListByPromptIDAndVersions.
func (mr *MockICommitLabelMappingDAOMockRecorder) ListByPromptIDAndVersions(ctx, promptID, versions any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, promptID, versions}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByPromptIDAndVersions", reflect.TypeOf((*MockICommitLabelMappingDAO)(nil).ListByPromptIDAndVersions), varargs...)
}

// MGetPromptVersionByLabelQuery mocks base method.
func (m *MockICommitLabelMappingDAO) MGetPromptVersionByLabelQuery(ctx context.Context, param mysql.MGetPromptVersionByLabelQueryParam, opts ...db.Option) ([]*model.PromptCommitLabelMapping, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, param}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGetPromptVersionByLabelQuery", varargs...)
	ret0, _ := ret[0].([]*model.PromptCommitLabelMapping)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGetPromptVersionByLabelQuery indicates an expected call of MGetPromptVersionByLabelQuery.
func (mr *MockICommitLabelMappingDAOMockRecorder) MGetPromptVersionByLabelQuery(ctx, param any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, param}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGetPromptVersionByLabelQuery", reflect.TypeOf((*MockICommitLabelMappingDAO)(nil).MGetPromptVersionByLabelQuery), varargs...)
}
