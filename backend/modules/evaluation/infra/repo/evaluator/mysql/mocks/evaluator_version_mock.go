// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql (interfaces: EvaluatorVersionDAO)
//
// Generated by this command:
//
//	mockgen -destination mocks/evaluator_version_mock.go -package=mocks . EvaluatorVersionDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	mysql "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockEvaluatorVersionDAO is a mock of EvaluatorVersionDAO interface.
type MockEvaluatorVersionDAO struct {
	ctrl     *gomock.Controller
	recorder *MockEvaluatorVersionDAOMockRecorder
	isgomock struct{}
}

// MockEvaluatorVersionDAOMockRecorder is the mock recorder for MockEvaluatorVersionDAO.
type MockEvaluatorVersionDAOMockRecorder struct {
	mock *MockEvaluatorVersionDAO
}

// NewMockEvaluatorVersionDAO creates a new mock instance.
func NewMockEvaluatorVersionDAO(ctrl *gomock.Controller) *MockEvaluatorVersionDAO {
	mock := &MockEvaluatorVersionDAO{ctrl: ctrl}
	mock.recorder = &MockEvaluatorVersionDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEvaluatorVersionDAO) EXPECT() *MockEvaluatorVersionDAOMockRecorder {
	return m.recorder
}

// BatchDeleteEvaluatorVersionByEvaluatorIDs mocks base method.
func (m *MockEvaluatorVersionDAO) BatchDeleteEvaluatorVersionByEvaluatorIDs(ctx context.Context, evaluatorIDs []int64, userID string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluatorIDs, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDeleteEvaluatorVersionByEvaluatorIDs", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchDeleteEvaluatorVersionByEvaluatorIDs indicates an expected call of BatchDeleteEvaluatorVersionByEvaluatorIDs.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchDeleteEvaluatorVersionByEvaluatorIDs(ctx, evaluatorIDs, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluatorIDs, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDeleteEvaluatorVersionByEvaluatorIDs", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchDeleteEvaluatorVersionByEvaluatorIDs), varargs...)
}

// BatchGetEvaluatorDraftByEvaluatorID mocks base method.
func (m *MockEvaluatorVersionDAO) BatchGetEvaluatorDraftByEvaluatorID(ctx context.Context, evaluatorIDs []int64, includeDeleted bool, opts ...db.Option) ([]*model.EvaluatorVersion, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluatorIDs, includeDeleted}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorDraftByEvaluatorID", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorDraftByEvaluatorID indicates an expected call of BatchGetEvaluatorDraftByEvaluatorID.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchGetEvaluatorDraftByEvaluatorID(ctx, evaluatorIDs, includeDeleted any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluatorIDs, includeDeleted}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorDraftByEvaluatorID", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchGetEvaluatorDraftByEvaluatorID), varargs...)
}

// BatchGetEvaluatorVersionByID mocks base method.
func (m *MockEvaluatorVersionDAO) BatchGetEvaluatorVersionByID(ctx context.Context, spaceID *int64, ids []int64, includeDeleted bool, opts ...db.Option) ([]*model.EvaluatorVersion, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, ids, includeDeleted}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorVersionByID", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorVersionByID indicates an expected call of BatchGetEvaluatorVersionByID.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchGetEvaluatorVersionByID(ctx, spaceID, ids, includeDeleted any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, ids, includeDeleted}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorVersionByID", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchGetEvaluatorVersionByID), varargs...)
}

// BatchGetEvaluatorVersionsByEvaluatorIDs mocks base method.
func (m *MockEvaluatorVersionDAO) BatchGetEvaluatorVersionsByEvaluatorIDs(ctx context.Context, evaluatorIDs []int64, includeDeleted bool, opts ...db.Option) ([]*model.EvaluatorVersion, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluatorIDs, includeDeleted}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorVersionsByEvaluatorIDs", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorVersionsByEvaluatorIDs indicates an expected call of BatchGetEvaluatorVersionsByEvaluatorIDs.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchGetEvaluatorVersionsByEvaluatorIDs(ctx, evaluatorIDs, includeDeleted any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluatorIDs, includeDeleted}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorVersionsByEvaluatorIDs", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchGetEvaluatorVersionsByEvaluatorIDs), varargs...)
}

// CheckVersionExist mocks base method.
func (m *MockEvaluatorVersionDAO) CheckVersionExist(ctx context.Context, evaluatorID int64, version string, opts ...db.Option) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluatorID, version}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckVersionExist", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckVersionExist indicates an expected call of CheckVersionExist.
func (mr *MockEvaluatorVersionDAOMockRecorder) CheckVersionExist(ctx, evaluatorID, version any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluatorID, version}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckVersionExist", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).CheckVersionExist), varargs...)
}

// CreateEvaluatorVersion mocks base method.
func (m *MockEvaluatorVersionDAO) CreateEvaluatorVersion(ctx context.Context, version *model.EvaluatorVersion, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, version}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateEvaluatorVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateEvaluatorVersion indicates an expected call of CreateEvaluatorVersion.
func (mr *MockEvaluatorVersionDAOMockRecorder) CreateEvaluatorVersion(ctx, version any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, version}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEvaluatorVersion", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).CreateEvaluatorVersion), varargs...)
}

// DeleteEvaluatorVersion mocks base method.
func (m *MockEvaluatorVersionDAO) DeleteEvaluatorVersion(ctx context.Context, id int64, userID string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, id, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteEvaluatorVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteEvaluatorVersion indicates an expected call of DeleteEvaluatorVersion.
func (mr *MockEvaluatorVersionDAOMockRecorder) DeleteEvaluatorVersion(ctx, id, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, id, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvaluatorVersion", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).DeleteEvaluatorVersion), varargs...)
}

// ListEvaluatorVersion mocks base method.
func (m *MockEvaluatorVersionDAO) ListEvaluatorVersion(ctx context.Context, req *mysql.ListEvaluatorVersionRequest, opts ...db.Option) (*mysql.ListEvaluatorVersionResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEvaluatorVersion", varargs...)
	ret0, _ := ret[0].(*mysql.ListEvaluatorVersionResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListEvaluatorVersion indicates an expected call of ListEvaluatorVersion.
func (mr *MockEvaluatorVersionDAOMockRecorder) ListEvaluatorVersion(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEvaluatorVersion", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).ListEvaluatorVersion), varargs...)
}

// UpdateEvaluatorDraft mocks base method.
func (m *MockEvaluatorVersionDAO) UpdateEvaluatorDraft(ctx context.Context, version *model.EvaluatorVersion, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, version}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorDraft", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorDraft indicates an expected call of UpdateEvaluatorDraft.
func (mr *MockEvaluatorVersionDAOMockRecorder) UpdateEvaluatorDraft(ctx, version any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, version}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorDraft", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).UpdateEvaluatorDraft), varargs...)
}
