// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql (interfaces: EvaluatorDAO)
//
// Generated by this command:
//
//	mockgen -destination mocks/evaluator_mock.go -package=mocks . EvaluatorDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	mysql "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockEvaluatorDAO is a mock of EvaluatorDAO interface.
type MockEvaluatorDAO struct {
	ctrl     *gomock.Controller
	recorder *MockEvaluatorDAOMockRecorder
	isgomock struct{}
}

// MockEvaluatorDAOMockRecorder is the mock recorder for MockEvaluatorDAO.
type MockEvaluatorDAOMockRecorder struct {
	mock *MockEvaluatorDAO
}

// NewMockEvaluatorDAO creates a new mock instance.
func NewMockEvaluatorDAO(ctrl *gomock.Controller) *MockEvaluatorDAO {
	mock := &MockEvaluatorDAO{ctrl: ctrl}
	mock.recorder = &MockEvaluatorDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEvaluatorDAO) EXPECT() *MockEvaluatorDAOMockRecorder {
	return m.recorder
}

// BatchDeleteEvaluator mocks base method.
func (m *MockEvaluatorDAO) BatchDeleteEvaluator(ctx context.Context, ids []int64, userID string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, ids, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDeleteEvaluator", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchDeleteEvaluator indicates an expected call of BatchDeleteEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) BatchDeleteEvaluator(ctx, ids, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, ids, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDeleteEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).BatchDeleteEvaluator), varargs...)
}

// BatchGetEvaluatorByID mocks base method.
func (m *MockEvaluatorDAO) BatchGetEvaluatorByID(ctx context.Context, ids []int64, includeDeleted bool, opts ...db.Option) ([]*model.Evaluator, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, ids, includeDeleted}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorByID", varargs...)
	ret0, _ := ret[0].([]*model.Evaluator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorByID indicates an expected call of BatchGetEvaluatorByID.
func (mr *MockEvaluatorDAOMockRecorder) BatchGetEvaluatorByID(ctx, ids, includeDeleted any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, ids, includeDeleted}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorByID", reflect.TypeOf((*MockEvaluatorDAO)(nil).BatchGetEvaluatorByID), varargs...)
}

// CheckNameExist mocks base method.
func (m *MockEvaluatorDAO) CheckNameExist(ctx context.Context, spaceID, evaluatorID int64, name string, opts ...db.Option) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, evaluatorID, name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckNameExist", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckNameExist indicates an expected call of CheckNameExist.
func (mr *MockEvaluatorDAOMockRecorder) CheckNameExist(ctx, spaceID, evaluatorID, name any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, evaluatorID, name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckNameExist", reflect.TypeOf((*MockEvaluatorDAO)(nil).CheckNameExist), varargs...)
}

// CreateEvaluator mocks base method.
func (m *MockEvaluatorDAO) CreateEvaluator(ctx context.Context, evaluator *model.Evaluator, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluator}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateEvaluator", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateEvaluator indicates an expected call of CreateEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) CreateEvaluator(ctx, evaluator any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluator}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).CreateEvaluator), varargs...)
}

// GetEvaluatorByID mocks base method.
func (m *MockEvaluatorDAO) GetEvaluatorByID(ctx context.Context, id int64, includeDeleted bool, opts ...db.Option) (*model.Evaluator, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, id, includeDeleted}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetEvaluatorByID", varargs...)
	ret0, _ := ret[0].(*model.Evaluator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEvaluatorByID indicates an expected call of GetEvaluatorByID.
func (mr *MockEvaluatorDAOMockRecorder) GetEvaluatorByID(ctx, id, includeDeleted any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, id, includeDeleted}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEvaluatorByID", reflect.TypeOf((*MockEvaluatorDAO)(nil).GetEvaluatorByID), varargs...)
}

// ListEvaluator mocks base method.
func (m *MockEvaluatorDAO) ListEvaluator(ctx context.Context, req *mysql.ListEvaluatorRequest, opts ...db.Option) (*mysql.ListEvaluatorResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEvaluator", varargs...)
	ret0, _ := ret[0].(*mysql.ListEvaluatorResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListEvaluator indicates an expected call of ListEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) ListEvaluator(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).ListEvaluator), varargs...)
}

// ListBuiltinEvaluator mocks base method.
func (m *MockEvaluatorDAO) ListBuiltinEvaluator(ctx context.Context, req *mysql.ListBuiltinEvaluatorRequest, opts ...db.Option) (*mysql.ListEvaluatorResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListBuiltinEvaluator", varargs...)
	ret0, _ := ret[0].(*mysql.ListEvaluatorResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBuiltinEvaluator indicates an expected call of ListBuiltinEvaluator.
func (mr *MockEvaluatorDAOMockRecorder) ListBuiltinEvaluator(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBuiltinEvaluator", reflect.TypeOf((*MockEvaluatorDAO)(nil).ListBuiltinEvaluator), varargs...)
}

// UpdateEvaluatorDraftSubmitted mocks base method.
func (m *MockEvaluatorDAO) UpdateEvaluatorDraftSubmitted(ctx context.Context, evaluatorID int64, draftSubmitted bool, userID string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluatorID, draftSubmitted, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorDraftSubmitted", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorDraftSubmitted indicates an expected call of UpdateEvaluatorDraftSubmitted.
func (mr *MockEvaluatorDAOMockRecorder) UpdateEvaluatorDraftSubmitted(ctx, evaluatorID, draftSubmitted, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluatorID, draftSubmitted, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorDraftSubmitted", reflect.TypeOf((*MockEvaluatorDAO)(nil).UpdateEvaluatorDraftSubmitted), varargs...)
}

// UpdateEvaluatorLatestVersion mocks base method.
func (m *MockEvaluatorDAO) UpdateEvaluatorLatestVersion(ctx context.Context, evaluatorID int64, version, userID string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, evaluatorID, version, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorLatestVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorLatestVersion indicates an expected call of UpdateEvaluatorLatestVersion.
func (mr *MockEvaluatorDAOMockRecorder) UpdateEvaluatorLatestVersion(ctx, evaluatorID, version, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, evaluatorID, version, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorLatestVersion", reflect.TypeOf((*MockEvaluatorDAO)(nil).UpdateEvaluatorLatestVersion), varargs...)
}

// UpdateEvaluatorMeta mocks base method.
func (m *MockEvaluatorDAO) UpdateEvaluatorMeta(ctx context.Context, do *model.Evaluator, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, do}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorMeta", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorMeta indicates an expected call of UpdateEvaluatorMeta.
func (mr *MockEvaluatorDAOMockRecorder) UpdateEvaluatorMeta(ctx, do any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, do}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorMeta", reflect.TypeOf((*MockEvaluatorDAO)(nil).UpdateEvaluatorMeta), varargs...)
}
