// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql (interfaces: EvaluatorTagDAO)
//
// Generated by this command:
//
//	mockgen -destination mocks/evaluator_tag_mock.go -package=mocks . EvaluatorTagDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	entity "github.com/coze-dev/coze-loop/backend/modules/evaluation/domain/entity"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockEvaluatorTagDAO is a mock of EvaluatorTagDAO interface.
type MockEvaluatorTagDAO struct {
	ctrl     *gomock.Controller
	recorder *MockEvaluatorTagDAOMockRecorder
	isgomock struct{}
}

// MockEvaluatorTagDAOMockRecorder is the mock recorder for MockEvaluatorTagDAO.
type MockEvaluatorTagDAOMockRecorder struct {
	mock *MockEvaluatorTagDAO
}

// NewMockEvaluatorTagDAO creates a new mock instance.
func NewMockEvaluatorTagDAO(ctrl *gomock.Controller) *MockEvaluatorTagDAO {
	mock := &MockEvaluatorTagDAO{ctrl: ctrl}
	mock.recorder = &MockEvaluatorTagDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEvaluatorTagDAO) EXPECT() *MockEvaluatorTagDAOMockRecorder {
	return m.recorder
}

// BatchCreateEvaluatorTags mocks base method.
func (m *MockEvaluatorTagDAO) BatchCreateEvaluatorTags(ctx context.Context, sourceID int64, tagType int32, userID string, tags map[string][]string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sourceID, tagType, userID, tags}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreateEvaluatorTags", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchCreateEvaluatorTags indicates an expected call of BatchCreateEvaluatorTags.
func (mr *MockEvaluatorTagDAOMockRecorder) BatchCreateEvaluatorTags(ctx, sourceID, tagType, userID, tags any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sourceID, tagType, userID, tags}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreateEvaluatorTags", reflect.TypeOf((*MockEvaluatorTagDAO)(nil).BatchCreateEvaluatorTags), varargs...)
}

// BatchGetTagsBySourceIDsAndType mocks base method.
func (m *MockEvaluatorTagDAO) BatchGetTagsBySourceIDsAndType(ctx context.Context, sourceIDs []int64, tagType int32, opts ...db.Option) ([]*model.EvaluatorTag, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sourceIDs, tagType}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetTagsBySourceIDsAndType", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetTagsBySourceIDsAndType indicates an expected call of BatchGetTagsBySourceIDsAndType.
func (mr *MockEvaluatorTagDAOMockRecorder) BatchGetTagsBySourceIDsAndType(ctx, sourceIDs, tagType any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sourceIDs, tagType}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetTagsBySourceIDsAndType", reflect.TypeOf((*MockEvaluatorTagDAO)(nil).BatchGetTagsBySourceIDsAndType), varargs...)
}

// DeleteEvaluatorTagsByConditions mocks base method.
func (m *MockEvaluatorTagDAO) DeleteEvaluatorTagsByConditions(ctx context.Context, sourceID int64, tagType int32, tags map[string][]string, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sourceID, tagType, tags}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteEvaluatorTagsByConditions", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteEvaluatorTagsByConditions indicates an expected call of DeleteEvaluatorTagsByConditions.
func (mr *MockEvaluatorTagDAOMockRecorder) DeleteEvaluatorTagsByConditions(ctx, sourceID, tagType, tags any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sourceID, tagType, tags}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvaluatorTagsByConditions", reflect.TypeOf((*MockEvaluatorTagDAO)(nil).DeleteEvaluatorTagsByConditions), varargs...)
}

// GetSourceIDsByFilterConditions mocks base method.
func (m *MockEvaluatorTagDAO) GetSourceIDsByFilterConditions(ctx context.Context, tagType int32, filterOption *entity.EvaluatorFilterOption, pageSize, pageNum int32, opts ...db.Option) ([]int64, int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, tagType, filterOption, pageSize, pageNum}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSourceIDsByFilterConditions", varargs...)
	ret0, _ := ret[0].([]int64)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetSourceIDsByFilterConditions indicates an expected call of GetSourceIDsByFilterConditions.
func (mr *MockEvaluatorTagDAOMockRecorder) GetSourceIDsByFilterConditions(ctx, tagType, filterOption, pageSize, pageNum any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, tagType, filterOption, pageSize, pageNum}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSourceIDsByFilterConditions", reflect.TypeOf((*MockEvaluatorTagDAO)(nil).GetSourceIDsByFilterConditions), varargs...)
}
