// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/experiment/mysql (interfaces: IExptItemResultDAO)
//
// Generated by this command:
//
//	mockgen -destination=mocks/expt_item_result.go -package mocks . IExptItemResultDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	entity "github.com/coze-dev/coze-loop/backend/modules/evaluation/domain/entity"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/experiment/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockIExptItemResultDAO is a mock of IExptItemResultDAO interface.
type MockIExptItemResultDAO struct {
	ctrl     *gomock.Controller
	recorder *MockIExptItemResultDAOMockRecorder
	isgomock struct{}
}

// MockIExptItemResultDAOMockRecorder is the mock recorder for MockIExptItemResultDAO.
type MockIExptItemResultDAOMockRecorder struct {
	mock *MockIExptItemResultDAO
}

// NewMockIExptItemResultDAO creates a new mock instance.
func NewMockIExptItemResultDAO(ctrl *gomock.Controller) *MockIExptItemResultDAO {
	mock := &MockIExptItemResultDAO{ctrl: ctrl}
	mock.recorder = &MockIExptItemResultDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIExptItemResultDAO) EXPECT() *MockIExptItemResultDAOMockRecorder {
	return m.recorder
}

// BatchCreateNX mocks base method.
func (m *MockIExptItemResultDAO) BatchCreateNX(ctx context.Context, itemResults []*model.ExptItemResult, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, itemResults}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreateNX", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchCreateNX indicates an expected call of BatchCreateNX.
func (mr *MockIExptItemResultDAOMockRecorder) BatchCreateNX(ctx, itemResults any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, itemResults}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreateNX", reflect.TypeOf((*MockIExptItemResultDAO)(nil).BatchCreateNX), varargs...)
}

// BatchCreateNXRunLogs mocks base method.
func (m *MockIExptItemResultDAO) BatchCreateNXRunLogs(ctx context.Context, itemRunLogs []*model.ExptItemResultRunLog, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, itemRunLogs}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreateNXRunLogs", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchCreateNXRunLogs indicates an expected call of BatchCreateNXRunLogs.
func (mr *MockIExptItemResultDAOMockRecorder) BatchCreateNXRunLogs(ctx, itemRunLogs any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, itemRunLogs}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreateNXRunLogs", reflect.TypeOf((*MockIExptItemResultDAO)(nil).BatchCreateNXRunLogs), varargs...)
}

// BatchGet mocks base method.
func (m *MockIExptItemResultDAO) BatchGet(ctx context.Context, spaceID, exptID int64, itemIDs []int64, opts ...db.Option) ([]*model.ExptItemResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, exptID, itemIDs}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGet", varargs...)
	ret0, _ := ret[0].([]*model.ExptItemResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGet indicates an expected call of BatchGet.
func (mr *MockIExptItemResultDAOMockRecorder) BatchGet(ctx, spaceID, exptID, itemIDs any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, exptID, itemIDs}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGet", reflect.TypeOf((*MockIExptItemResultDAO)(nil).BatchGet), varargs...)
}

// GetItemIDListByExptID mocks base method.
func (m *MockIExptItemResultDAO) GetItemIDListByExptID(ctx context.Context, exptID, spaceID int64) ([]int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItemIDListByExptID", ctx, exptID, spaceID)
	ret0, _ := ret[0].([]int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemIDListByExptID indicates an expected call of GetItemIDListByExptID.
func (mr *MockIExptItemResultDAOMockRecorder) GetItemIDListByExptID(ctx, exptID, spaceID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemIDListByExptID", reflect.TypeOf((*MockIExptItemResultDAO)(nil).GetItemIDListByExptID), ctx, exptID, spaceID)
}

// GetItemRunLog mocks base method.
func (m *MockIExptItemResultDAO) GetItemRunLog(ctx context.Context, exptID, exptRunID, itemID, spaceID int64, opts ...db.Option) (*model.ExptItemResultRunLog, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptID, exptRunID, itemID, spaceID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetItemRunLog", varargs...)
	ret0, _ := ret[0].(*model.ExptItemResultRunLog)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemRunLog indicates an expected call of GetItemRunLog.
func (mr *MockIExptItemResultDAOMockRecorder) GetItemRunLog(ctx, exptID, exptRunID, itemID, spaceID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptID, exptRunID, itemID, spaceID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemRunLog", reflect.TypeOf((*MockIExptItemResultDAO)(nil).GetItemRunLog), varargs...)
}

// GetItemTurnResults mocks base method.
func (m *MockIExptItemResultDAO) GetItemTurnResults(ctx context.Context, spaceID, exptID, itemID int64, opts ...db.Option) ([]*model.ExptTurnResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, exptID, itemID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetItemTurnResults", varargs...)
	ret0, _ := ret[0].([]*model.ExptTurnResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetItemTurnResults indicates an expected call of GetItemTurnResults.
func (mr *MockIExptItemResultDAOMockRecorder) GetItemTurnResults(ctx, spaceID, exptID, itemID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, exptID, itemID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemTurnResults", reflect.TypeOf((*MockIExptItemResultDAO)(nil).GetItemTurnResults), varargs...)
}

// GetMaxItemIdxByExptID mocks base method.
func (m *MockIExptItemResultDAO) GetMaxItemIdxByExptID(ctx context.Context, exptID, spaceID int64, opts ...db.Option) (int32, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptID, spaceID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMaxItemIdxByExptID", varargs...)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMaxItemIdxByExptID indicates an expected call of GetMaxItemIdxByExptID.
func (mr *MockIExptItemResultDAOMockRecorder) GetMaxItemIdxByExptID(ctx, exptID, spaceID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptID, spaceID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxItemIdxByExptID", reflect.TypeOf((*MockIExptItemResultDAO)(nil).GetMaxItemIdxByExptID), varargs...)
}

// ListItemResultsByExptID mocks base method.
func (m *MockIExptItemResultDAO) ListItemResultsByExptID(ctx context.Context, exptID, spaceID int64, page entity.Page, desc bool) ([]*model.ExptItemResult, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListItemResultsByExptID", ctx, exptID, spaceID, page, desc)
	ret0, _ := ret[0].([]*model.ExptItemResult)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListItemResultsByExptID indicates an expected call of ListItemResultsByExptID.
func (mr *MockIExptItemResultDAOMockRecorder) ListItemResultsByExptID(ctx, exptID, spaceID, page, desc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListItemResultsByExptID", reflect.TypeOf((*MockIExptItemResultDAO)(nil).ListItemResultsByExptID), ctx, exptID, spaceID, page, desc)
}

// MGetItemResults mocks base method.
func (m *MockIExptItemResultDAO) MGetItemResults(ctx context.Context, spaceID, exptID int64, itemIDs []int64, opts ...db.Option) ([]*model.ExptItemResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, exptID, itemIDs}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGetItemResults", varargs...)
	ret0, _ := ret[0].([]*model.ExptItemResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGetItemResults indicates an expected call of MGetItemResults.
func (mr *MockIExptItemResultDAOMockRecorder) MGetItemResults(ctx, spaceID, exptID, itemIDs any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, exptID, itemIDs}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGetItemResults", reflect.TypeOf((*MockIExptItemResultDAO)(nil).MGetItemResults), varargs...)
}

// MGetItemRunLog mocks base method.
func (m *MockIExptItemResultDAO) MGetItemRunLog(ctx context.Context, exptID, exptRunID int64, itemIDs []int64, spaceID int64, opts ...db.Option) ([]*model.ExptItemResultRunLog, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptID, exptRunID, itemIDs, spaceID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGetItemRunLog", varargs...)
	ret0, _ := ret[0].([]*model.ExptItemResultRunLog)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGetItemRunLog indicates an expected call of MGetItemRunLog.
func (mr *MockIExptItemResultDAOMockRecorder) MGetItemRunLog(ctx, exptID, exptRunID, itemIDs, spaceID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptID, exptRunID, itemIDs, spaceID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGetItemRunLog", reflect.TypeOf((*MockIExptItemResultDAO)(nil).MGetItemRunLog), varargs...)
}

// MGetItemTurnResults mocks base method.
func (m *MockIExptItemResultDAO) MGetItemTurnResults(ctx context.Context, spaceID, exptID int64, itemIDs []int64, opts ...db.Option) ([]*model.ExptTurnResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, exptID, itemIDs}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGetItemTurnResults", varargs...)
	ret0, _ := ret[0].([]*model.ExptTurnResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGetItemTurnResults indicates an expected call of MGetItemTurnResults.
func (mr *MockIExptItemResultDAOMockRecorder) MGetItemTurnResults(ctx, spaceID, exptID, itemIDs any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, exptID, itemIDs}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGetItemTurnResults", reflect.TypeOf((*MockIExptItemResultDAO)(nil).MGetItemTurnResults), varargs...)
}

// SaveItemResults mocks base method.
func (m *MockIExptItemResultDAO) SaveItemResults(ctx context.Context, itemResults []*model.ExptItemResult, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, itemResults}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveItemResults", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveItemResults indicates an expected call of SaveItemResults.
func (mr *MockIExptItemResultDAOMockRecorder) SaveItemResults(ctx, itemResults any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, itemResults}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveItemResults", reflect.TypeOf((*MockIExptItemResultDAO)(nil).SaveItemResults), varargs...)
}

// ScanItemResults mocks base method.
func (m *MockIExptItemResultDAO) ScanItemResults(ctx context.Context, exptID, cursor, limit int64, status []int32, spaceID int64, opts ...db.Option) ([]*model.ExptItemResult, int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptID, cursor, limit, status, spaceID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanItemResults", varargs...)
	ret0, _ := ret[0].([]*model.ExptItemResult)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ScanItemResults indicates an expected call of ScanItemResults.
func (mr *MockIExptItemResultDAOMockRecorder) ScanItemResults(ctx, exptID, cursor, limit, status, spaceID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptID, cursor, limit, status, spaceID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanItemResults", reflect.TypeOf((*MockIExptItemResultDAO)(nil).ScanItemResults), varargs...)
}

// ScanItemRunLogs mocks base method.
func (m *MockIExptItemResultDAO) ScanItemRunLogs(ctx context.Context, exptID, exptRunID int64, filter *entity.ExptItemRunLogFilter, cursor, limit, spaceID int64, opts ...db.Option) ([]*model.ExptItemResultRunLog, int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptID, exptRunID, filter, cursor, limit, spaceID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanItemRunLogs", varargs...)
	ret0, _ := ret[0].([]*model.ExptItemResultRunLog)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ScanItemRunLogs indicates an expected call of ScanItemRunLogs.
func (mr *MockIExptItemResultDAOMockRecorder) ScanItemRunLogs(ctx, exptID, exptRunID, filter, cursor, limit, spaceID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptID, exptRunID, filter, cursor, limit, spaceID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanItemRunLogs", reflect.TypeOf((*MockIExptItemResultDAO)(nil).ScanItemRunLogs), varargs...)
}

// UpdateItemRunLog mocks base method.
func (m *MockIExptItemResultDAO) UpdateItemRunLog(ctx context.Context, exptID, exptRunID int64, itemID []int64, ufields map[string]any, spaceID int64, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptID, exptRunID, itemID, ufields, spaceID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateItemRunLog", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateItemRunLog indicates an expected call of UpdateItemRunLog.
func (mr *MockIExptItemResultDAOMockRecorder) UpdateItemRunLog(ctx, exptID, exptRunID, itemID, ufields, spaceID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptID, exptRunID, itemID, ufields, spaceID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateItemRunLog", reflect.TypeOf((*MockIExptItemResultDAO)(nil).UpdateItemRunLog), varargs...)
}

// UpdateItemsResult mocks base method.
func (m *MockIExptItemResultDAO) UpdateItemsResult(ctx context.Context, spaceID, exptID int64, itemID []int64, ufields map[string]any, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, spaceID, exptID, itemID, ufields}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateItemsResult", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateItemsResult indicates an expected call of UpdateItemsResult.
func (mr *MockIExptItemResultDAOMockRecorder) UpdateItemsResult(ctx, spaceID, exptID, itemID, ufields any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, spaceID, exptID, itemID, ufields}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateItemsResult", reflect.TypeOf((*MockIExptItemResultDAO)(nil).UpdateItemsResult), varargs...)
}
