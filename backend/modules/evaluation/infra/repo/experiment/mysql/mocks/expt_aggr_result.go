// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/experiment/mysql (interfaces: ExptAggrResultDAO)
//
// Generated by this command:
//
//	mockgen -destination=mocks/expt_aggr_result.go -package mocks . ExptAggrResultDAO
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/experiment/mysql/gorm_gen/model"
	gomock "go.uber.org/mock/gomock"
)

// MockExptAggrResultDAO is a mock of ExptAggrResultDAO interface.
type MockExptAggrResultDAO struct {
	ctrl     *gomock.Controller
	recorder *MockExptAggrResultDAOMockRecorder
	isgomock struct{}
}

// MockExptAggrResultDAOMockRecorder is the mock recorder for MockExptAggrResultDAO.
type MockExptAggrResultDAOMockRecorder struct {
	mock *MockExptAggrResultDAO
}

// NewMockExptAggrResultDAO creates a new mock instance.
func NewMockExptAggrResultDAO(ctrl *gomock.Controller) *MockExptAggrResultDAO {
	mock := &MockExptAggrResultDAO{ctrl: ctrl}
	mock.recorder = &MockExptAggrResultDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExptAggrResultDAO) EXPECT() *MockExptAggrResultDAOMockRecorder {
	return m.recorder
}

// BatchCreateExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) BatchCreateExptAggrResult(ctx context.Context, exptAggrResults []*model.ExptAggrResult, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptAggrResults}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreateExptAggrResult", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchCreateExptAggrResult indicates an expected call of BatchCreateExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) BatchCreateExptAggrResult(ctx, exptAggrResults any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptAggrResults}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreateExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).BatchCreateExptAggrResult), varargs...)
}

// BatchGetExptAggrResultByExperimentIDs mocks base method.
func (m *MockExptAggrResultDAO) BatchGetExptAggrResultByExperimentIDs(ctx context.Context, experimentIDs []int64, opts ...db.Option) ([]*model.ExptAggrResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, experimentIDs}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetExptAggrResultByExperimentIDs", varargs...)
	ret0, _ := ret[0].([]*model.ExptAggrResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetExptAggrResultByExperimentIDs indicates an expected call of BatchGetExptAggrResultByExperimentIDs.
func (mr *MockExptAggrResultDAOMockRecorder) BatchGetExptAggrResultByExperimentIDs(ctx, experimentIDs any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, experimentIDs}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetExptAggrResultByExperimentIDs", reflect.TypeOf((*MockExptAggrResultDAO)(nil).BatchGetExptAggrResultByExperimentIDs), varargs...)
}

// CreateExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) CreateExptAggrResult(ctx context.Context, exptAggrResult *model.ExptAggrResult, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptAggrResult}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateExptAggrResult", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateExptAggrResult indicates an expected call of CreateExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) CreateExptAggrResult(ctx, exptAggrResult any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptAggrResult}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).CreateExptAggrResult), varargs...)
}

// DeleteExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) DeleteExptAggrResult(ctx context.Context, exptAggrResult *model.ExptAggrResult, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptAggrResult}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteExptAggrResult", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteExptAggrResult indicates an expected call of DeleteExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) DeleteExptAggrResult(ctx, exptAggrResult any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptAggrResult}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).DeleteExptAggrResult), varargs...)
}

// GetExptAggrResult mocks base method.
func (m *MockExptAggrResultDAO) GetExptAggrResult(ctx context.Context, experimentID int64, fieldType int32, fieldKey string, opts ...db.Option) (*model.ExptAggrResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, experimentID, fieldType, fieldKey}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExptAggrResult", varargs...)
	ret0, _ := ret[0].(*model.ExptAggrResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExptAggrResult indicates an expected call of GetExptAggrResult.
func (mr *MockExptAggrResultDAOMockRecorder) GetExptAggrResult(ctx, experimentID, fieldType, fieldKey any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, experimentID, fieldType, fieldKey}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExptAggrResult", reflect.TypeOf((*MockExptAggrResultDAO)(nil).GetExptAggrResult), varargs...)
}

// GetExptAggrResultByExperimentID mocks base method.
func (m *MockExptAggrResultDAO) GetExptAggrResultByExperimentID(ctx context.Context, experimentID int64, opts ...db.Option) ([]*model.ExptAggrResult, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, experimentID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExptAggrResultByExperimentID", varargs...)
	ret0, _ := ret[0].([]*model.ExptAggrResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExptAggrResultByExperimentID indicates an expected call of GetExptAggrResultByExperimentID.
func (mr *MockExptAggrResultDAOMockRecorder) GetExptAggrResultByExperimentID(ctx, experimentID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, experimentID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExptAggrResultByExperimentID", reflect.TypeOf((*MockExptAggrResultDAO)(nil).GetExptAggrResultByExperimentID), varargs...)
}

// UpdateAndGetLatestVersion mocks base method.
func (m *MockExptAggrResultDAO) UpdateAndGetLatestVersion(ctx context.Context, experimentID int64, fieldType int32, fieldKey string, opts ...db.Option) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, experimentID, fieldType, fieldKey}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAndGetLatestVersion", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAndGetLatestVersion indicates an expected call of UpdateAndGetLatestVersion.
func (mr *MockExptAggrResultDAOMockRecorder) UpdateAndGetLatestVersion(ctx, experimentID, fieldType, fieldKey any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, experimentID, fieldType, fieldKey}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAndGetLatestVersion", reflect.TypeOf((*MockExptAggrResultDAO)(nil).UpdateAndGetLatestVersion), varargs...)
}

// UpdateExptAggrResultByVersion mocks base method.
func (m *MockExptAggrResultDAO) UpdateExptAggrResultByVersion(ctx context.Context, exptAggrResult *model.ExptAggrResult, taskVersion int64, opts ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exptAggrResult, taskVersion}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateExptAggrResultByVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateExptAggrResultByVersion indicates an expected call of UpdateExptAggrResultByVersion.
func (mr *MockExptAggrResultDAOMockRecorder) UpdateExptAggrResultByVersion(ctx, exptAggrResult, taskVersion any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exptAggrResult, taskVersion}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateExptAggrResultByVersion", reflect.TypeOf((*MockExptAggrResultDAO)(nil).UpdateExptAggrResultByVersion), varargs...)
}
