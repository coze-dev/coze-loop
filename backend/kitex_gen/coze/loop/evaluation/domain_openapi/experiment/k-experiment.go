// Code generated by Kitex v0.13.1. DO NOT EDIT.

package experiment

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/cloudwego/gopkg/protocol/thrift"
	kutils "github.com/cloudwego/kitex/pkg/utils"

	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain_openapi/common"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain_openapi/eval_set"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain_openapi/evaluator"
)

var (
	_ = common.KitexUnusedProtection
	_ = eval_set.KitexUnusedProtection
	_ = evaluator.KitexUnusedProtection
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.STOP
)

func (p *FieldMapping) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FieldMapping[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FieldMapping) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FieldName = _field
	return offset, nil
}

func (p *FieldMapping) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FromFieldName = _field
	return offset, nil
}

func (p *FieldMapping) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ConstValue = _field
	return offset, nil
}

func (p *FieldMapping) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FieldMapping) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FieldMapping) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FieldMapping) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFieldName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.FieldName)
	}
	return offset
}

func (p *FieldMapping) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromFieldName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.FromFieldName)
	}
	return offset
}

func (p *FieldMapping) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetConstValue() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ConstValue)
	}
	return offset
}

func (p *FieldMapping) field1Length() int {
	l := 0
	if p.IsSetFieldName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.FieldName)
	}
	return l
}

func (p *FieldMapping) field2Length() int {
	l := 0
	if p.IsSetFromFieldName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.FromFieldName)
	}
	return l
}

func (p *FieldMapping) field3Length() int {
	l := 0
	if p.IsSetConstValue() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ConstValue)
	}
	return l
}

func (p *FieldMapping) DeepCopy(s interface{}) error {
	src, ok := s.(*FieldMapping)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.FieldName != nil {
		var tmp string
		if *src.FieldName != "" {
			tmp = kutils.StringDeepCopy(*src.FieldName)
		}
		p.FieldName = &tmp
	}

	if src.FromFieldName != nil {
		var tmp string
		if *src.FromFieldName != "" {
			tmp = kutils.StringDeepCopy(*src.FromFieldName)
		}
		p.FromFieldName = &tmp
	}

	if src.ConstValue != nil {
		var tmp string
		if *src.ConstValue != "" {
			tmp = kutils.StringDeepCopy(*src.ConstValue)
		}
		p.ConstValue = &tmp
	}

	return nil
}

func (p *TargetFieldMapping) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TargetFieldMapping[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TargetFieldMapping) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldMapping, 0, size)
	values := make([]FieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FromEvalSet = _field
	return offset, nil
}

func (p *TargetFieldMapping) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TargetFieldMapping) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TargetFieldMapping) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TargetFieldMapping) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromEvalSet() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FromEvalSet {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *TargetFieldMapping) field1Length() int {
	l := 0
	if p.IsSetFromEvalSet() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FromEvalSet {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *TargetFieldMapping) DeepCopy(s interface{}) error {
	src, ok := s.(*TargetFieldMapping)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.FromEvalSet != nil {
		p.FromEvalSet = make([]*FieldMapping, 0, len(src.FromEvalSet))
		for _, elem := range src.FromEvalSet {
			var _elem *FieldMapping
			if elem != nil {
				_elem = &FieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FromEvalSet = append(p.FromEvalSet, _elem)
		}
	}

	return nil
}

func (p *EvaluatorFieldMapping) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_EvaluatorFieldMapping[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *EvaluatorFieldMapping) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorVersionID = _field
	return offset, nil
}

func (p *EvaluatorFieldMapping) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldMapping, 0, size)
	values := make([]FieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FromEvalSet = _field
	return offset, nil
}

func (p *EvaluatorFieldMapping) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldMapping, 0, size)
	values := make([]FieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FromTarget = _field
	return offset, nil
}

func (p *EvaluatorFieldMapping) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *EvaluatorFieldMapping) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *EvaluatorFieldMapping) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *EvaluatorFieldMapping) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvaluatorVersionID)
	}
	return offset
}

func (p *EvaluatorFieldMapping) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromEvalSet() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FromEvalSet {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *EvaluatorFieldMapping) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromTarget() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 3)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FromTarget {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *EvaluatorFieldMapping) field1Length() int {
	l := 0
	if p.IsSetEvaluatorVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvaluatorVersionID)
	}
	return l
}

func (p *EvaluatorFieldMapping) field2Length() int {
	l := 0
	if p.IsSetFromEvalSet() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FromEvalSet {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *EvaluatorFieldMapping) field3Length() int {
	l := 0
	if p.IsSetFromTarget() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FromTarget {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *EvaluatorFieldMapping) DeepCopy(s interface{}) error {
	src, ok := s.(*EvaluatorFieldMapping)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorVersionID != nil {
		var tmp string
		if *src.EvaluatorVersionID != "" {
			tmp = kutils.StringDeepCopy(*src.EvaluatorVersionID)
		}
		p.EvaluatorVersionID = &tmp
	}

	if src.FromEvalSet != nil {
		p.FromEvalSet = make([]*FieldMapping, 0, len(src.FromEvalSet))
		for _, elem := range src.FromEvalSet {
			var _elem *FieldMapping
			if elem != nil {
				_elem = &FieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FromEvalSet = append(p.FromEvalSet, _elem)
		}
	}

	if src.FromTarget != nil {
		p.FromTarget = make([]*FieldMapping, 0, len(src.FromTarget))
		for _, elem := range src.FromTarget {
			var _elem *FieldMapping
			if elem != nil {
				_elem = &FieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FromTarget = append(p.FromTarget, _elem)
		}
	}

	return nil
}

func (p *TokenUsage) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TokenUsage[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TokenUsage) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.InputTokens = _field
	return offset, nil
}

func (p *TokenUsage) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.OutputTokens = _field
	return offset, nil
}

func (p *TokenUsage) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TokenUsage) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TokenUsage) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TokenUsage) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetInputTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.InputTokens)
	}
	return offset
}

func (p *TokenUsage) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOutputTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.OutputTokens)
	}
	return offset
}

func (p *TokenUsage) field1Length() int {
	l := 0
	if p.IsSetInputTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.InputTokens)
	}
	return l
}

func (p *TokenUsage) field2Length() int {
	l := 0
	if p.IsSetOutputTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.OutputTokens)
	}
	return l
}

func (p *TokenUsage) DeepCopy(s interface{}) error {
	src, ok := s.(*TokenUsage)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.InputTokens != nil {
		var tmp string
		if *src.InputTokens != "" {
			tmp = kutils.StringDeepCopy(*src.InputTokens)
		}
		p.InputTokens = &tmp
	}

	if src.OutputTokens != nil {
		var tmp string
		if *src.OutputTokens != "" {
			tmp = kutils.StringDeepCopy(*src.OutputTokens)
		}
		p.OutputTokens = &tmp
	}

	return nil
}

func (p *EvaluatorAggregateResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_EvaluatorAggregateResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *EvaluatorAggregateResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorVersionID = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorName = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AverageScore = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxScore = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MinScore = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SuccessCount = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FailedCount = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *EvaluatorAggregateResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *EvaluatorAggregateResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *EvaluatorAggregateResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvaluatorVersionID)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvaluatorName)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAverageScore() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 3)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.AverageScore)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxScore() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 4)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.MaxScore)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMinScore() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 5)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.MinScore)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSuccessCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 6)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.SuccessCount)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFailedCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 7)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.FailedCount)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) field1Length() int {
	l := 0
	if p.IsSetEvaluatorVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvaluatorVersionID)
	}
	return l
}

func (p *EvaluatorAggregateResult_) field2Length() int {
	l := 0
	if p.IsSetEvaluatorName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvaluatorName)
	}
	return l
}

func (p *EvaluatorAggregateResult_) field3Length() int {
	l := 0
	if p.IsSetAverageScore() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *EvaluatorAggregateResult_) field4Length() int {
	l := 0
	if p.IsSetMaxScore() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *EvaluatorAggregateResult_) field5Length() int {
	l := 0
	if p.IsSetMinScore() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *EvaluatorAggregateResult_) field6Length() int {
	l := 0
	if p.IsSetSuccessCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *EvaluatorAggregateResult_) field7Length() int {
	l := 0
	if p.IsSetFailedCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *EvaluatorAggregateResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*EvaluatorAggregateResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorVersionID != nil {
		var tmp string
		if *src.EvaluatorVersionID != "" {
			tmp = kutils.StringDeepCopy(*src.EvaluatorVersionID)
		}
		p.EvaluatorVersionID = &tmp
	}

	if src.EvaluatorName != nil {
		var tmp string
		if *src.EvaluatorName != "" {
			tmp = kutils.StringDeepCopy(*src.EvaluatorName)
		}
		p.EvaluatorName = &tmp
	}

	if src.AverageScore != nil {
		tmp := *src.AverageScore
		p.AverageScore = &tmp
	}

	if src.MaxScore != nil {
		tmp := *src.MaxScore
		p.MaxScore = &tmp
	}

	if src.MinScore != nil {
		tmp := *src.MinScore
		p.MinScore = &tmp
	}

	if src.SuccessCount != nil {
		tmp := *src.SuccessCount
		p.SuccessCount = &tmp
	}

	if src.FailedCount != nil {
		tmp := *src.FailedCount
		p.FailedCount = &tmp
	}

	return nil
}

func (p *ExperimentStatistics) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExperimentStatistics[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExperimentStatistics) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*EvaluatorAggregateResult_, 0, size)
	values := make([]EvaluatorAggregateResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.EvaluatorAggregateResults = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewTokenUsage()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TokenUsage = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreditCost = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.PendingTurnCount = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SuccessTurnCount = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FailedTurnCount = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TerminatedTurnCount = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastReadField8(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ProcessingTurnCount = _field
	return offset, nil
}

func (p *ExperimentStatistics) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExperimentStatistics) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExperimentStatistics) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExperimentStatistics) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorAggregateResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.EvaluatorAggregateResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTokenUsage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.TokenUsage.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreditCost() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 3)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.CreditCost)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetPendingTurnCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 4)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.PendingTurnCount)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSuccessTurnCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 5)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.SuccessTurnCount)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFailedTurnCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 6)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.FailedTurnCount)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTerminatedTurnCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 7)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.TerminatedTurnCount)
	}
	return offset
}

func (p *ExperimentStatistics) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProcessingTurnCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 8)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.ProcessingTurnCount)
	}
	return offset
}

func (p *ExperimentStatistics) field1Length() int {
	l := 0
	if p.IsSetEvaluatorAggregateResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.EvaluatorAggregateResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ExperimentStatistics) field2Length() int {
	l := 0
	if p.IsSetTokenUsage() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TokenUsage.BLength()
	}
	return l
}

func (p *ExperimentStatistics) field3Length() int {
	l := 0
	if p.IsSetCreditCost() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *ExperimentStatistics) field4Length() int {
	l := 0
	if p.IsSetPendingTurnCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExperimentStatistics) field5Length() int {
	l := 0
	if p.IsSetSuccessTurnCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExperimentStatistics) field6Length() int {
	l := 0
	if p.IsSetFailedTurnCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExperimentStatistics) field7Length() int {
	l := 0
	if p.IsSetTerminatedTurnCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExperimentStatistics) field8Length() int {
	l := 0
	if p.IsSetProcessingTurnCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExperimentStatistics) DeepCopy(s interface{}) error {
	src, ok := s.(*ExperimentStatistics)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorAggregateResults != nil {
		p.EvaluatorAggregateResults = make([]*EvaluatorAggregateResult_, 0, len(src.EvaluatorAggregateResults))
		for _, elem := range src.EvaluatorAggregateResults {
			var _elem *EvaluatorAggregateResult_
			if elem != nil {
				_elem = &EvaluatorAggregateResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.EvaluatorAggregateResults = append(p.EvaluatorAggregateResults, _elem)
		}
	}

	var _tokenUsage *TokenUsage
	if src.TokenUsage != nil {
		_tokenUsage = &TokenUsage{}
		if err := _tokenUsage.DeepCopy(src.TokenUsage); err != nil {
			return err
		}
	}
	p.TokenUsage = _tokenUsage

	if src.CreditCost != nil {
		tmp := *src.CreditCost
		p.CreditCost = &tmp
	}

	if src.PendingTurnCount != nil {
		tmp := *src.PendingTurnCount
		p.PendingTurnCount = &tmp
	}

	if src.SuccessTurnCount != nil {
		tmp := *src.SuccessTurnCount
		p.SuccessTurnCount = &tmp
	}

	if src.FailedTurnCount != nil {
		tmp := *src.FailedTurnCount
		p.FailedTurnCount = &tmp
	}

	if src.TerminatedTurnCount != nil {
		tmp := *src.TerminatedTurnCount
		p.TerminatedTurnCount = &tmp
	}

	if src.ProcessingTurnCount != nil {
		tmp := *src.ProcessingTurnCount
		p.ProcessingTurnCount = &tmp
	}

	return nil
}

func (p *Experiment) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Experiment[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *Experiment) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ExperimentID = _field
	return offset, nil
}

func (p *Experiment) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *Experiment) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *Experiment) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *ExperimentStatus
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Status = _field
	return offset, nil
}

func (p *Experiment) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.StatusMessage = _field
	return offset, nil
}

func (p *Experiment) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.StartTime = _field
	return offset, nil
}

func (p *Experiment) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EndTime = _field
	return offset, nil
}

func (p *Experiment) FastReadField8(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvalSetVersionID = _field
	return offset, nil
}

func (p *Experiment) FastReadField9(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TargetVersionID = _field
	return offset, nil
}

func (p *Experiment) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_elem = v
		}

		_field = append(_field, _elem)
	}
	p.EvaluatorVersionIds = _field
	return offset, nil
}

func (p *Experiment) FastReadField11(buf []byte) (int, error) {
	offset := 0
	_field := NewTargetFieldMapping()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TargetFieldMapping = _field
	return offset, nil
}

func (p *Experiment) FastReadField12(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*EvaluatorFieldMapping, 0, size)
	values := make([]EvaluatorFieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.EvaluatorFieldMapping = _field
	return offset, nil
}

func (p *Experiment) FastReadField13(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemConcurNum = _field
	return offset, nil
}

func (p *Experiment) FastReadField14(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorsConcurNum = _field
	return offset, nil
}

func (p *Experiment) FastReadField15(buf []byte) (int, error) {
	offset := 0

	var _field *ExperimentType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ExperimentType = _field
	return offset, nil
}

func (p *Experiment) FastReadField16(buf []byte) (int, error) {
	offset := 0
	_field := NewExperimentStatistics()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExperimentStatistics = _field
	return offset, nil
}

func (p *Experiment) FastReadField17(buf []byte) (int, error) {
	offset := 0
	_field := common.NewBaseInfo()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BaseInfo = _field
	return offset, nil
}

func (p *Experiment) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Experiment) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField13(buf[offset:], w)
		offset += p.fastWriteField14(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField9(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
		offset += p.fastWriteField11(buf[offset:], w)
		offset += p.fastWriteField12(buf[offset:], w)
		offset += p.fastWriteField15(buf[offset:], w)
		offset += p.fastWriteField16(buf[offset:], w)
		offset += p.fastWriteField17(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Experiment) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Experiment) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExperimentID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ExperimentID)
	}
	return offset
}

func (p *Experiment) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *Experiment) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *Experiment) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Status)
	}
	return offset
}

func (p *Experiment) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatusMessage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.StatusMessage)
	}
	return offset
}

func (p *Experiment) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStartTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.StartTime)
	}
	return offset
}

func (p *Experiment) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEndTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 7)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EndTime)
	}
	return offset
}

func (p *Experiment) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalSetVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 8)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvalSetVersionID)
	}
	return offset
}

func (p *Experiment) fastWriteField9(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 9)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TargetVersionID)
	}
	return offset
}

func (p *Experiment) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorVersionIds() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 10)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.EvaluatorVersionIds {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, v)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	}
	return offset
}

func (p *Experiment) fastWriteField11(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetFieldMapping() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 11)
		offset += p.TargetFieldMapping.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField12(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorFieldMapping() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 12)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.EvaluatorFieldMapping {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *Experiment) fastWriteField13(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemConcurNum() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 13)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.ItemConcurNum)
	}
	return offset
}

func (p *Experiment) fastWriteField14(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorsConcurNum() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 14)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.EvaluatorsConcurNum)
	}
	return offset
}

func (p *Experiment) fastWriteField15(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExperimentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 15)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ExperimentType)
	}
	return offset
}

func (p *Experiment) fastWriteField16(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExperimentStatistics() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 16)
		offset += p.ExperimentStatistics.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField17(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBaseInfo() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 17)
		offset += p.BaseInfo.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) field1Length() int {
	l := 0
	if p.IsSetExperimentID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ExperimentID)
	}
	return l
}

func (p *Experiment) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *Experiment) field3Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *Experiment) field4Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Status)
	}
	return l
}

func (p *Experiment) field5Length() int {
	l := 0
	if p.IsSetStatusMessage() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.StatusMessage)
	}
	return l
}

func (p *Experiment) field6Length() int {
	l := 0
	if p.IsSetStartTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.StartTime)
	}
	return l
}

func (p *Experiment) field7Length() int {
	l := 0
	if p.IsSetEndTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EndTime)
	}
	return l
}

func (p *Experiment) field8Length() int {
	l := 0
	if p.IsSetEvalSetVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvalSetVersionID)
	}
	return l
}

func (p *Experiment) field9Length() int {
	l := 0
	if p.IsSetTargetVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TargetVersionID)
	}
	return l
}

func (p *Experiment) field10Length() int {
	l := 0
	if p.IsSetEvaluatorVersionIds() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.EvaluatorVersionIds {
			_ = v
			l += thrift.Binary.StringLengthNocopy(v)
		}
	}
	return l
}

func (p *Experiment) field11Length() int {
	l := 0
	if p.IsSetTargetFieldMapping() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TargetFieldMapping.BLength()
	}
	return l
}

func (p *Experiment) field12Length() int {
	l := 0
	if p.IsSetEvaluatorFieldMapping() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.EvaluatorFieldMapping {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *Experiment) field13Length() int {
	l := 0
	if p.IsSetItemConcurNum() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Experiment) field14Length() int {
	l := 0
	if p.IsSetEvaluatorsConcurNum() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Experiment) field15Length() int {
	l := 0
	if p.IsSetExperimentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ExperimentType)
	}
	return l
}

func (p *Experiment) field16Length() int {
	l := 0
	if p.IsSetExperimentStatistics() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ExperimentStatistics.BLength()
	}
	return l
}

func (p *Experiment) field17Length() int {
	l := 0
	if p.IsSetBaseInfo() {
		l += thrift.Binary.FieldBeginLength()
		l += p.BaseInfo.BLength()
	}
	return l
}

func (p *Experiment) DeepCopy(s interface{}) error {
	src, ok := s.(*Experiment)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ExperimentID != nil {
		var tmp string
		if *src.ExperimentID != "" {
			tmp = kutils.StringDeepCopy(*src.ExperimentID)
		}
		p.ExperimentID = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.StatusMessage != nil {
		var tmp string
		if *src.StatusMessage != "" {
			tmp = kutils.StringDeepCopy(*src.StatusMessage)
		}
		p.StatusMessage = &tmp
	}

	if src.StartTime != nil {
		var tmp string
		if *src.StartTime != "" {
			tmp = kutils.StringDeepCopy(*src.StartTime)
		}
		p.StartTime = &tmp
	}

	if src.EndTime != nil {
		var tmp string
		if *src.EndTime != "" {
			tmp = kutils.StringDeepCopy(*src.EndTime)
		}
		p.EndTime = &tmp
	}

	if src.EvalSetVersionID != nil {
		var tmp string
		if *src.EvalSetVersionID != "" {
			tmp = kutils.StringDeepCopy(*src.EvalSetVersionID)
		}
		p.EvalSetVersionID = &tmp
	}

	if src.TargetVersionID != nil {
		var tmp string
		if *src.TargetVersionID != "" {
			tmp = kutils.StringDeepCopy(*src.TargetVersionID)
		}
		p.TargetVersionID = &tmp
	}

	if src.EvaluatorVersionIds != nil {
		p.EvaluatorVersionIds = make([]string, 0, len(src.EvaluatorVersionIds))
		for _, elem := range src.EvaluatorVersionIds {
			var _elem string
			if elem != "" {
				_elem = kutils.StringDeepCopy(elem)
			}
			p.EvaluatorVersionIds = append(p.EvaluatorVersionIds, _elem)
		}
	}

	var _targetFieldMapping *TargetFieldMapping
	if src.TargetFieldMapping != nil {
		_targetFieldMapping = &TargetFieldMapping{}
		if err := _targetFieldMapping.DeepCopy(src.TargetFieldMapping); err != nil {
			return err
		}
	}
	p.TargetFieldMapping = _targetFieldMapping

	if src.EvaluatorFieldMapping != nil {
		p.EvaluatorFieldMapping = make([]*EvaluatorFieldMapping, 0, len(src.EvaluatorFieldMapping))
		for _, elem := range src.EvaluatorFieldMapping {
			var _elem *EvaluatorFieldMapping
			if elem != nil {
				_elem = &EvaluatorFieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.EvaluatorFieldMapping = append(p.EvaluatorFieldMapping, _elem)
		}
	}

	if src.ItemConcurNum != nil {
		tmp := *src.ItemConcurNum
		p.ItemConcurNum = &tmp
	}

	if src.EvaluatorsConcurNum != nil {
		tmp := *src.EvaluatorsConcurNum
		p.EvaluatorsConcurNum = &tmp
	}

	if src.ExperimentType != nil {
		tmp := *src.ExperimentType
		p.ExperimentType = &tmp
	}

	var _experimentStatistics *ExperimentStatistics
	if src.ExperimentStatistics != nil {
		_experimentStatistics = &ExperimentStatistics{}
		if err := _experimentStatistics.DeepCopy(src.ExperimentStatistics); err != nil {
			return err
		}
	}
	p.ExperimentStatistics = _experimentStatistics

	var _baseInfo *common.BaseInfo
	if src.BaseInfo != nil {
		_baseInfo = &common.BaseInfo{}
		if err := _baseInfo.DeepCopy(src.BaseInfo); err != nil {
			return err
		}
	}
	p.BaseInfo = _baseInfo

	return nil
}

func (p *ColumnEvalSetField) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ColumnEvalSetField[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ColumnEvalSetField) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Key = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *common.ContentType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ContentType = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ColumnEvalSetField) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ColumnEvalSetField) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ColumnEvalSetField) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Key)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ContentType)
	}
	return offset
}

func (p *ColumnEvalSetField) field1Length() int {
	l := 0
	if p.IsSetKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Key)
	}
	return l
}

func (p *ColumnEvalSetField) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *ColumnEvalSetField) field3Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *ColumnEvalSetField) field4Length() int {
	l := 0
	if p.IsSetContentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ContentType)
	}
	return l
}

func (p *ColumnEvalSetField) DeepCopy(s interface{}) error {
	src, ok := s.(*ColumnEvalSetField)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Key != nil {
		var tmp string
		if *src.Key != "" {
			tmp = kutils.StringDeepCopy(*src.Key)
		}
		p.Key = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.ContentType != nil {
		tmp := *src.ContentType
		p.ContentType = &tmp
	}

	return nil
}

func (p *ColumnEvaluator) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ColumnEvaluator[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ColumnEvaluator) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorVersionID = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorID = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *evaluator.EvaluatorType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvaluatorType = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Version = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ColumnEvaluator) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ColumnEvaluator) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ColumnEvaluator) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvaluatorVersionID)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvaluatorID)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.EvaluatorType)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Version)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *ColumnEvaluator) field1Length() int {
	l := 0
	if p.IsSetEvaluatorVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvaluatorVersionID)
	}
	return l
}

func (p *ColumnEvaluator) field2Length() int {
	l := 0
	if p.IsSetEvaluatorID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvaluatorID)
	}
	return l
}

func (p *ColumnEvaluator) field3Length() int {
	l := 0
	if p.IsSetEvaluatorType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.EvaluatorType)
	}
	return l
}

func (p *ColumnEvaluator) field4Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *ColumnEvaluator) field5Length() int {
	l := 0
	if p.IsSetVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Version)
	}
	return l
}

func (p *ColumnEvaluator) field6Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *ColumnEvaluator) DeepCopy(s interface{}) error {
	src, ok := s.(*ColumnEvaluator)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorVersionID != nil {
		var tmp string
		if *src.EvaluatorVersionID != "" {
			tmp = kutils.StringDeepCopy(*src.EvaluatorVersionID)
		}
		p.EvaluatorVersionID = &tmp
	}

	if src.EvaluatorID != nil {
		var tmp string
		if *src.EvaluatorID != "" {
			tmp = kutils.StringDeepCopy(*src.EvaluatorID)
		}
		p.EvaluatorID = &tmp
	}

	if src.EvaluatorType != nil {
		tmp := *src.EvaluatorType
		p.EvaluatorType = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Version != nil {
		var tmp string
		if *src.Version != "" {
			tmp = kutils.StringDeepCopy(*src.Version)
		}
		p.Version = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	return nil
}

func (p *TargetOutput) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TargetOutput[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TargetOutput) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TargetRecordID = _field
	return offset, nil
}

func (p *TargetOutput) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *evaluator.EvaluatorRunStatus
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Status = _field
	return offset, nil
}

func (p *TargetOutput) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[string]*common.Content, size)
	values := make([]common.Content, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.OutputFields = _field
	return offset, nil
}

func (p *TargetOutput) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TimeConsumingMs = _field
	return offset, nil
}

func (p *TargetOutput) FastReadField5(buf []byte) (int, error) {
	offset := 0
	_field := evaluator.NewEvaluatorRunError()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Error = _field
	return offset, nil
}

func (p *TargetOutput) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TargetOutput) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TargetOutput) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TargetOutput) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetRecordID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TargetRecordID)
	}
	return offset
}

func (p *TargetOutput) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Status)
	}
	return offset
}

func (p *TargetOutput) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOutputFields() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 3)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.OutputFields {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, k)
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRUCT, length)
	}
	return offset
}

func (p *TargetOutput) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTimeConsumingMs() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TimeConsumingMs)
	}
	return offset
}

func (p *TargetOutput) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetError() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 5)
		offset += p.Error.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *TargetOutput) field1Length() int {
	l := 0
	if p.IsSetTargetRecordID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TargetRecordID)
	}
	return l
}

func (p *TargetOutput) field2Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Status)
	}
	return l
}

func (p *TargetOutput) field3Length() int {
	l := 0
	if p.IsSetOutputFields() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.OutputFields {
			_, _ = k, v

			l += thrift.Binary.StringLengthNocopy(k)
			l += v.BLength()
		}
	}
	return l
}

func (p *TargetOutput) field4Length() int {
	l := 0
	if p.IsSetTimeConsumingMs() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TimeConsumingMs)
	}
	return l
}

func (p *TargetOutput) field5Length() int {
	l := 0
	if p.IsSetError() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Error.BLength()
	}
	return l
}

func (p *TargetOutput) DeepCopy(s interface{}) error {
	src, ok := s.(*TargetOutput)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.TargetRecordID != nil {
		var tmp string
		if *src.TargetRecordID != "" {
			tmp = kutils.StringDeepCopy(*src.TargetRecordID)
		}
		p.TargetRecordID = &tmp
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.OutputFields != nil {
		p.OutputFields = make(map[string]*common.Content, len(src.OutputFields))
		for key, val := range src.OutputFields {
			var _key string
			if key != "" {
				_key = kutils.StringDeepCopy(key)
			}

			var _val *common.Content
			if val != nil {
				_val = &common.Content{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.OutputFields[_key] = _val
		}
	}

	if src.TimeConsumingMs != nil {
		var tmp string
		if *src.TimeConsumingMs != "" {
			tmp = kutils.StringDeepCopy(*src.TimeConsumingMs)
		}
		p.TimeConsumingMs = &tmp
	}

	var _error *evaluator.EvaluatorRunError
	if src.Error != nil {
		_error = &evaluator.EvaluatorRunError{}
		if err := _error.DeepCopy(src.Error); err != nil {
			return err
		}
	}
	p.Error = _error

	return nil
}

func (p *EvaluatorOutput) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_EvaluatorOutput[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *EvaluatorOutput) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[string]*evaluator.EvaluatorRecord, size)
	values := make([]evaluator.EvaluatorRecord, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.EvaluatorRecords = _field
	return offset, nil
}

func (p *EvaluatorOutput) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *EvaluatorOutput) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *EvaluatorOutput) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *EvaluatorOutput) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorRecords() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 1)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.EvaluatorRecords {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, k)
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRUCT, length)
	}
	return offset
}

func (p *EvaluatorOutput) field1Length() int {
	l := 0
	if p.IsSetEvaluatorRecords() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.EvaluatorRecords {
			_, _ = k, v

			l += thrift.Binary.StringLengthNocopy(k)
			l += v.BLength()
		}
	}
	return l
}

func (p *EvaluatorOutput) DeepCopy(s interface{}) error {
	src, ok := s.(*EvaluatorOutput)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorRecords != nil {
		p.EvaluatorRecords = make(map[string]*evaluator.EvaluatorRecord, len(src.EvaluatorRecords))
		for key, val := range src.EvaluatorRecords {
			var _key string
			if key != "" {
				_key = kutils.StringDeepCopy(key)
			}

			var _val *evaluator.EvaluatorRecord
			if val != nil {
				_val = &evaluator.EvaluatorRecord{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.EvaluatorRecords[_key] = _val
		}
	}

	return nil
}

func (p *ExperimentResultPayload) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExperimentResultPayload[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExperimentResultPayload) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TurnID = _field
	return offset, nil
}

func (p *ExperimentResultPayload) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := eval_set.NewTurn()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvalSetTurn = _field
	return offset, nil
}

func (p *ExperimentResultPayload) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewTargetOutput()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TargetOutput = _field
	return offset, nil
}

func (p *ExperimentResultPayload) FastReadField4(buf []byte) (int, error) {
	offset := 0
	_field := NewEvaluatorOutput()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvaluatorOutput = _field
	return offset, nil
}

func (p *ExperimentResultPayload) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExperimentResultPayload) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExperimentResultPayload) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExperimentResultPayload) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTurnID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TurnID)
	}
	return offset
}

func (p *ExperimentResultPayload) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalSetTurn() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.EvalSetTurn.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentResultPayload) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetOutput() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.TargetOutput.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentResultPayload) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorOutput() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 4)
		offset += p.EvaluatorOutput.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentResultPayload) field1Length() int {
	l := 0
	if p.IsSetTurnID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TurnID)
	}
	return l
}

func (p *ExperimentResultPayload) field2Length() int {
	l := 0
	if p.IsSetEvalSetTurn() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvalSetTurn.BLength()
	}
	return l
}

func (p *ExperimentResultPayload) field3Length() int {
	l := 0
	if p.IsSetTargetOutput() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TargetOutput.BLength()
	}
	return l
}

func (p *ExperimentResultPayload) field4Length() int {
	l := 0
	if p.IsSetEvaluatorOutput() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvaluatorOutput.BLength()
	}
	return l
}

func (p *ExperimentResultPayload) DeepCopy(s interface{}) error {
	src, ok := s.(*ExperimentResultPayload)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.TurnID != nil {
		var tmp string
		if *src.TurnID != "" {
			tmp = kutils.StringDeepCopy(*src.TurnID)
		}
		p.TurnID = &tmp
	}

	var _evalSetTurn *eval_set.Turn
	if src.EvalSetTurn != nil {
		_evalSetTurn = &eval_set.Turn{}
		if err := _evalSetTurn.DeepCopy(src.EvalSetTurn); err != nil {
			return err
		}
	}
	p.EvalSetTurn = _evalSetTurn

	var _targetOutput *TargetOutput
	if src.TargetOutput != nil {
		_targetOutput = &TargetOutput{}
		if err := _targetOutput.DeepCopy(src.TargetOutput); err != nil {
			return err
		}
	}
	p.TargetOutput = _targetOutput

	var _evaluatorOutput *EvaluatorOutput
	if src.EvaluatorOutput != nil {
		_evaluatorOutput = &EvaluatorOutput{}
		if err := _evaluatorOutput.DeepCopy(src.EvaluatorOutput); err != nil {
			return err
		}
	}
	p.EvaluatorOutput = _evaluatorOutput

	return nil
}

func (p *TurnResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TurnID = _field
	return offset, nil
}

func (p *TurnResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ExperimentResult_, 0, size)
	values := make([]ExperimentResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.ExperimentResults = _field
	return offset, nil
}

func (p *TurnResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTurnID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TurnID)
	}
	return offset
}

func (p *TurnResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExperimentResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.ExperimentResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *TurnResult_) field1Length() int {
	l := 0
	if p.IsSetTurnID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TurnID)
	}
	return l
}

func (p *TurnResult_) field2Length() int {
	l := 0
	if p.IsSetExperimentResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.ExperimentResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *TurnResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.TurnID != nil {
		var tmp string
		if *src.TurnID != "" {
			tmp = kutils.StringDeepCopy(*src.TurnID)
		}
		p.TurnID = &tmp
	}

	if src.ExperimentResults != nil {
		p.ExperimentResults = make([]*ExperimentResult_, 0, len(src.ExperimentResults))
		for _, elem := range src.ExperimentResults {
			var _elem *ExperimentResult_
			if elem != nil {
				_elem = &ExperimentResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.ExperimentResults = append(p.ExperimentResults, _elem)
		}
	}

	return nil
}

func (p *ExperimentResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExperimentResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExperimentResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ExperimentID = _field
	return offset, nil
}

func (p *ExperimentResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewExperimentResultPayload()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Payload = _field
	return offset, nil
}

func (p *ExperimentResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExperimentResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExperimentResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExperimentResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExperimentID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ExperimentID)
	}
	return offset
}

func (p *ExperimentResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetPayload() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.Payload.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentResult_) field1Length() int {
	l := 0
	if p.IsSetExperimentID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ExperimentID)
	}
	return l
}

func (p *ExperimentResult_) field2Length() int {
	l := 0
	if p.IsSetPayload() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Payload.BLength()
	}
	return l
}

func (p *ExperimentResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*ExperimentResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ExperimentID != nil {
		var tmp string
		if *src.ExperimentID != "" {
			tmp = kutils.StringDeepCopy(*src.ExperimentID)
		}
		p.ExperimentID = &tmp
	}

	var _payload *ExperimentResultPayload
	if src.Payload != nil {
		_payload = &ExperimentResultPayload{}
		if err := _payload.DeepCopy(src.Payload); err != nil {
			return err
		}
	}
	p.Payload = _payload

	return nil
}

func (p *ItemResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ItemResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ItemResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemID = _field
	return offset, nil
}

func (p *ItemResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*TurnResult_, 0, size)
	values := make([]TurnResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.TurnResults = _field
	return offset, nil
}

func (p *ItemResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ItemResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ItemResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ItemResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ItemID)
	}
	return offset
}

func (p *ItemResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTurnResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.TurnResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ItemResult_) field1Length() int {
	l := 0
	if p.IsSetItemID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ItemID)
	}
	return l
}

func (p *ItemResult_) field2Length() int {
	l := 0
	if p.IsSetTurnResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.TurnResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ItemResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*ItemResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ItemID != nil {
		var tmp string
		if *src.ItemID != "" {
			tmp = kutils.StringDeepCopy(*src.ItemID)
		}
		p.ItemID = &tmp
	}

	if src.TurnResults != nil {
		p.TurnResults = make([]*TurnResult_, 0, len(src.TurnResults))
		for _, elem := range src.TurnResults {
			var _elem *TurnResult_
			if elem != nil {
				_elem = &TurnResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.TurnResults = append(p.TurnResults, _elem)
		}
	}

	return nil
}
