// Code generated by Kitex v0.13.1. DO NOT EDIT.

package expt

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/cloudwego/gopkg/protocol/thrift"
	kutils "github.com/cloudwego/kitex/pkg/utils"

	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/data/domain/tag"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain/common"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain/eval_set"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain/eval_target"
	"github.com/coze-dev/coze-loop/backend/kitex_gen/coze/loop/evaluation/domain/evaluator"
)

var (
	_ = tag.KitexUnusedProtection
	_ = common.KitexUnusedProtection
	_ = eval_set.KitexUnusedProtection
	_ = eval_target.KitexUnusedProtection
	_ = evaluator.KitexUnusedProtection
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.STOP
)

func (p *Experiment) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 22:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField22(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 23:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField23(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 24:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField24(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 25:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField25(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 26:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField26(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 27:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField27(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 28:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField28(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 29:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField29(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 30:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField30(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 31:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField31(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 32:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField32(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 33:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField33(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 40:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField40(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 41:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField41(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 42:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField42(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 43:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField43(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Experiment[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *Experiment) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ID = _field
	return offset, nil
}

func (p *Experiment) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *Experiment) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Desc = _field
	return offset, nil
}

func (p *Experiment) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatorBy = _field
	return offset, nil
}

func (p *Experiment) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *ExptStatus
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ExptStatus(v)
		_field = &tmp
	}
	p.Status = _field
	return offset, nil
}

func (p *Experiment) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.StatusMessage = _field
	return offset, nil
}

func (p *Experiment) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.StartTime = _field
	return offset, nil
}

func (p *Experiment) FastReadField8(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EndTime = _field
	return offset, nil
}

func (p *Experiment) FastReadField9(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemConcurNum = _field
	return offset, nil
}

func (p *Experiment) FastReadField21(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvalSetVersionID = _field
	return offset, nil
}

func (p *Experiment) FastReadField22(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TargetVersionID = _field
	return offset, nil
}

func (p *Experiment) FastReadField23(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]int64, 0, size)
	for i := 0; i < size; i++ {
		var _elem int64
		if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_elem = v
		}

		_field = append(_field, _elem)
	}
	p.EvaluatorVersionIds = _field
	return offset, nil
}

func (p *Experiment) FastReadField24(buf []byte) (int, error) {
	offset := 0
	_field := eval_set.NewEvaluationSet()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvalSet = _field
	return offset, nil
}

func (p *Experiment) FastReadField25(buf []byte) (int, error) {
	offset := 0
	_field := eval_target.NewEvalTarget()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvalTarget = _field
	return offset, nil
}

func (p *Experiment) FastReadField26(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*evaluator.Evaluator, 0, size)
	values := make([]evaluator.Evaluator, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Evaluators = _field
	return offset, nil
}

func (p *Experiment) FastReadField27(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EvalSetID = _field
	return offset, nil
}

func (p *Experiment) FastReadField28(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TargetID = _field
	return offset, nil
}

func (p *Experiment) FastReadField29(buf []byte) (int, error) {
	offset := 0
	_field := common.NewBaseInfo()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BaseInfo = _field
	return offset, nil
}

func (p *Experiment) FastReadField30(buf []byte) (int, error) {
	offset := 0
	_field := NewExptStatistics()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExptStats = _field
	return offset, nil
}

func (p *Experiment) FastReadField31(buf []byte) (int, error) {
	offset := 0
	_field := NewTargetFieldMapping()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TargetFieldMapping = _field
	return offset, nil
}

func (p *Experiment) FastReadField32(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*EvaluatorFieldMapping, 0, size)
	values := make([]EvaluatorFieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.EvaluatorFieldMapping = _field
	return offset, nil
}

func (p *Experiment) FastReadField33(buf []byte) (int, error) {
	offset := 0
	_field := common.NewRuntimeParam()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TargetRuntimeParam = _field
	return offset, nil
}

func (p *Experiment) FastReadField40(buf []byte) (int, error) {
	offset := 0

	var _field *ExptType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ExptType(v)
		_field = &tmp
	}
	p.ExptType = _field
	return offset, nil
}

func (p *Experiment) FastReadField41(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxAliveTime = _field
	return offset, nil
}

func (p *Experiment) FastReadField42(buf []byte) (int, error) {
	offset := 0

	var _field *SourceType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := SourceType(v)
		_field = &tmp
	}
	p.SourceType = _field
	return offset, nil
}

func (p *Experiment) FastReadField43(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SourceID = _field
	return offset, nil
}

func (p *Experiment) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Experiment) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField9(buf[offset:], w)
		offset += p.fastWriteField21(buf[offset:], w)
		offset += p.fastWriteField22(buf[offset:], w)
		offset += p.fastWriteField27(buf[offset:], w)
		offset += p.fastWriteField28(buf[offset:], w)
		offset += p.fastWriteField41(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField23(buf[offset:], w)
		offset += p.fastWriteField24(buf[offset:], w)
		offset += p.fastWriteField25(buf[offset:], w)
		offset += p.fastWriteField26(buf[offset:], w)
		offset += p.fastWriteField29(buf[offset:], w)
		offset += p.fastWriteField30(buf[offset:], w)
		offset += p.fastWriteField31(buf[offset:], w)
		offset += p.fastWriteField32(buf[offset:], w)
		offset += p.fastWriteField33(buf[offset:], w)
		offset += p.fastWriteField40(buf[offset:], w)
		offset += p.fastWriteField42(buf[offset:], w)
		offset += p.fastWriteField43(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Experiment) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field21Length()
		l += p.field22Length()
		l += p.field23Length()
		l += p.field24Length()
		l += p.field25Length()
		l += p.field26Length()
		l += p.field27Length()
		l += p.field28Length()
		l += p.field29Length()
		l += p.field30Length()
		l += p.field31Length()
		l += p.field32Length()
		l += p.field33Length()
		l += p.field40Length()
		l += p.field41Length()
		l += p.field42Length()
		l += p.field43Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Experiment) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ID)
	}
	return offset
}

func (p *Experiment) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *Experiment) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDesc() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Desc)
	}
	return offset
}

func (p *Experiment) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatorBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CreatorBy)
	}
	return offset
}

func (p *Experiment) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 5)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Status))
	}
	return offset
}

func (p *Experiment) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatusMessage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.StatusMessage)
	}
	return offset
}

func (p *Experiment) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStartTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 7)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.StartTime)
	}
	return offset
}

func (p *Experiment) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEndTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 8)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.EndTime)
	}
	return offset
}

func (p *Experiment) fastWriteField9(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemConcurNum() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 9)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.ItemConcurNum)
	}
	return offset
}

func (p *Experiment) fastWriteField21(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalSetVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 21)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.EvalSetVersionID)
	}
	return offset
}

func (p *Experiment) fastWriteField22(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetVersionID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 22)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.TargetVersionID)
	}
	return offset
}

func (p *Experiment) fastWriteField23(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorVersionIds() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 23)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.EvaluatorVersionIds {
			length++
			offset += thrift.Binary.WriteI64(buf[offset:], v)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I64, length)
	}
	return offset
}

func (p *Experiment) fastWriteField24(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalSet() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 24)
		offset += p.EvalSet.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField25(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalTarget() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 25)
		offset += p.EvalTarget.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField26(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluators() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 26)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Evaluators {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *Experiment) fastWriteField27(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalSetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 27)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.EvalSetID)
	}
	return offset
}

func (p *Experiment) fastWriteField28(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 28)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.TargetID)
	}
	return offset
}

func (p *Experiment) fastWriteField29(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBaseInfo() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 29)
		offset += p.BaseInfo.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField30(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExptStats() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 30)
		offset += p.ExptStats.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField31(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetFieldMapping() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 31)
		offset += p.TargetFieldMapping.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField32(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorFieldMapping() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 32)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.EvaluatorFieldMapping {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *Experiment) fastWriteField33(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetRuntimeParam() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 33)
		offset += p.TargetRuntimeParam.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Experiment) fastWriteField40(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExptType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 40)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.ExptType))
	}
	return offset
}

func (p *Experiment) fastWriteField41(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxAliveTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 41)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxAliveTime)
	}
	return offset
}

func (p *Experiment) fastWriteField42(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSourceType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 42)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.SourceType))
	}
	return offset
}

func (p *Experiment) fastWriteField43(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSourceID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 43)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SourceID)
	}
	return offset
}

func (p *Experiment) field1Length() int {
	l := 0
	if p.IsSetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *Experiment) field3Length() int {
	l := 0
	if p.IsSetDesc() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Desc)
	}
	return l
}

func (p *Experiment) field4Length() int {
	l := 0
	if p.IsSetCreatorBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CreatorBy)
	}
	return l
}

func (p *Experiment) field5Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Experiment) field6Length() int {
	l := 0
	if p.IsSetStatusMessage() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.StatusMessage)
	}
	return l
}

func (p *Experiment) field7Length() int {
	l := 0
	if p.IsSetStartTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field8Length() int {
	l := 0
	if p.IsSetEndTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field9Length() int {
	l := 0
	if p.IsSetItemConcurNum() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Experiment) field21Length() int {
	l := 0
	if p.IsSetEvalSetVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field22Length() int {
	l := 0
	if p.IsSetTargetVersionID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field23Length() int {
	l := 0
	if p.IsSetEvaluatorVersionIds() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		l +=
			thrift.Binary.I64Length() * len(p.EvaluatorVersionIds)
	}
	return l
}

func (p *Experiment) field24Length() int {
	l := 0
	if p.IsSetEvalSet() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvalSet.BLength()
	}
	return l
}

func (p *Experiment) field25Length() int {
	l := 0
	if p.IsSetEvalTarget() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvalTarget.BLength()
	}
	return l
}

func (p *Experiment) field26Length() int {
	l := 0
	if p.IsSetEvaluators() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Evaluators {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *Experiment) field27Length() int {
	l := 0
	if p.IsSetEvalSetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field28Length() int {
	l := 0
	if p.IsSetTargetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field29Length() int {
	l := 0
	if p.IsSetBaseInfo() {
		l += thrift.Binary.FieldBeginLength()
		l += p.BaseInfo.BLength()
	}
	return l
}

func (p *Experiment) field30Length() int {
	l := 0
	if p.IsSetExptStats() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ExptStats.BLength()
	}
	return l
}

func (p *Experiment) field31Length() int {
	l := 0
	if p.IsSetTargetFieldMapping() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TargetFieldMapping.BLength()
	}
	return l
}

func (p *Experiment) field32Length() int {
	l := 0
	if p.IsSetEvaluatorFieldMapping() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.EvaluatorFieldMapping {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *Experiment) field33Length() int {
	l := 0
	if p.IsSetTargetRuntimeParam() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TargetRuntimeParam.BLength()
	}
	return l
}

func (p *Experiment) field40Length() int {
	l := 0
	if p.IsSetExptType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Experiment) field41Length() int {
	l := 0
	if p.IsSetMaxAliveTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Experiment) field42Length() int {
	l := 0
	if p.IsSetSourceType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Experiment) field43Length() int {
	l := 0
	if p.IsSetSourceID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SourceID)
	}
	return l
}

func (p *Experiment) DeepCopy(s interface{}) error {
	src, ok := s.(*Experiment)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ID != nil {
		tmp := *src.ID
		p.ID = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Desc != nil {
		var tmp string
		if *src.Desc != "" {
			tmp = kutils.StringDeepCopy(*src.Desc)
		}
		p.Desc = &tmp
	}

	if src.CreatorBy != nil {
		var tmp string
		if *src.CreatorBy != "" {
			tmp = kutils.StringDeepCopy(*src.CreatorBy)
		}
		p.CreatorBy = &tmp
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.StatusMessage != nil {
		var tmp string
		if *src.StatusMessage != "" {
			tmp = kutils.StringDeepCopy(*src.StatusMessage)
		}
		p.StatusMessage = &tmp
	}

	if src.StartTime != nil {
		tmp := *src.StartTime
		p.StartTime = &tmp
	}

	if src.EndTime != nil {
		tmp := *src.EndTime
		p.EndTime = &tmp
	}

	if src.ItemConcurNum != nil {
		tmp := *src.ItemConcurNum
		p.ItemConcurNum = &tmp
	}

	if src.EvalSetVersionID != nil {
		tmp := *src.EvalSetVersionID
		p.EvalSetVersionID = &tmp
	}

	if src.TargetVersionID != nil {
		tmp := *src.TargetVersionID
		p.TargetVersionID = &tmp
	}

	if src.EvaluatorVersionIds != nil {
		p.EvaluatorVersionIds = make([]int64, 0, len(src.EvaluatorVersionIds))
		for _, elem := range src.EvaluatorVersionIds {
			var _elem int64
			_elem = elem
			p.EvaluatorVersionIds = append(p.EvaluatorVersionIds, _elem)
		}
	}

	var _evalSet *eval_set.EvaluationSet
	if src.EvalSet != nil {
		_evalSet = &eval_set.EvaluationSet{}
		if err := _evalSet.DeepCopy(src.EvalSet); err != nil {
			return err
		}
	}
	p.EvalSet = _evalSet

	var _evalTarget *eval_target.EvalTarget
	if src.EvalTarget != nil {
		_evalTarget = &eval_target.EvalTarget{}
		if err := _evalTarget.DeepCopy(src.EvalTarget); err != nil {
			return err
		}
	}
	p.EvalTarget = _evalTarget

	if src.Evaluators != nil {
		p.Evaluators = make([]*evaluator.Evaluator, 0, len(src.Evaluators))
		for _, elem := range src.Evaluators {
			var _elem *evaluator.Evaluator
			if elem != nil {
				_elem = &evaluator.Evaluator{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Evaluators = append(p.Evaluators, _elem)
		}
	}

	if src.EvalSetID != nil {
		tmp := *src.EvalSetID
		p.EvalSetID = &tmp
	}

	if src.TargetID != nil {
		tmp := *src.TargetID
		p.TargetID = &tmp
	}

	var _baseInfo *common.BaseInfo
	if src.BaseInfo != nil {
		_baseInfo = &common.BaseInfo{}
		if err := _baseInfo.DeepCopy(src.BaseInfo); err != nil {
			return err
		}
	}
	p.BaseInfo = _baseInfo

	var _exptStats *ExptStatistics
	if src.ExptStats != nil {
		_exptStats = &ExptStatistics{}
		if err := _exptStats.DeepCopy(src.ExptStats); err != nil {
			return err
		}
	}
	p.ExptStats = _exptStats

	var _targetFieldMapping *TargetFieldMapping
	if src.TargetFieldMapping != nil {
		_targetFieldMapping = &TargetFieldMapping{}
		if err := _targetFieldMapping.DeepCopy(src.TargetFieldMapping); err != nil {
			return err
		}
	}
	p.TargetFieldMapping = _targetFieldMapping

	if src.EvaluatorFieldMapping != nil {
		p.EvaluatorFieldMapping = make([]*EvaluatorFieldMapping, 0, len(src.EvaluatorFieldMapping))
		for _, elem := range src.EvaluatorFieldMapping {
			var _elem *EvaluatorFieldMapping
			if elem != nil {
				_elem = &EvaluatorFieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.EvaluatorFieldMapping = append(p.EvaluatorFieldMapping, _elem)
		}
	}

	var _targetRuntimeParam *common.RuntimeParam
	if src.TargetRuntimeParam != nil {
		_targetRuntimeParam = &common.RuntimeParam{}
		if err := _targetRuntimeParam.DeepCopy(src.TargetRuntimeParam); err != nil {
			return err
		}
	}
	p.TargetRuntimeParam = _targetRuntimeParam

	if src.ExptType != nil {
		tmp := *src.ExptType
		p.ExptType = &tmp
	}

	if src.MaxAliveTime != nil {
		tmp := *src.MaxAliveTime
		p.MaxAliveTime = &tmp
	}

	if src.SourceType != nil {
		tmp := *src.SourceType
		p.SourceType = &tmp
	}

	if src.SourceID != nil {
		var tmp string
		if *src.SourceID != "" {
			tmp = kutils.StringDeepCopy(*src.SourceID)
		}
		p.SourceID = &tmp
	}

	return nil
}

func (p *TokenUsage) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TokenUsage[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TokenUsage) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.InputTokens = _field
	return offset, nil
}

func (p *TokenUsage) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.OutputTokens = _field
	return offset, nil
}

func (p *TokenUsage) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TokenUsage) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TokenUsage) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TokenUsage) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetInputTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.InputTokens)
	}
	return offset
}

func (p *TokenUsage) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOutputTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.OutputTokens)
	}
	return offset
}

func (p *TokenUsage) field1Length() int {
	l := 0
	if p.IsSetInputTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *TokenUsage) field2Length() int {
	l := 0
	if p.IsSetOutputTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *TokenUsage) DeepCopy(s interface{}) error {
	src, ok := s.(*TokenUsage)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.InputTokens != nil {
		tmp := *src.InputTokens
		p.InputTokens = &tmp
	}

	if src.OutputTokens != nil {
		tmp := *src.OutputTokens
		p.OutputTokens = &tmp
	}

	return nil
}

func (p *ExptStatistics) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptStatistics[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExptStatistics) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*EvaluatorAggregateResult_, 0, size)
	values := make([]EvaluatorAggregateResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.EvaluatorAggregateResults = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewTokenUsage()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TokenUsage = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreditCost = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.PendingTurnCnt = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SuccessTurnCnt = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FailTurnCnt = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TerminatedTurnCnt = _field
	return offset, nil
}

func (p *ExptStatistics) FastReadField8(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ProcessingTurnCnt = _field
	return offset, nil
}

func (p *ExptStatistics) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptStatistics) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptStatistics) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptStatistics) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorAggregateResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.EvaluatorAggregateResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTokenUsage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.TokenUsage.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreditCost() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 3)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.CreditCost)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetPendingTurnCnt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 4)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.PendingTurnCnt)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSuccessTurnCnt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 5)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.SuccessTurnCnt)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFailTurnCnt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 6)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.FailTurnCnt)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTerminatedTurnCnt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 7)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.TerminatedTurnCnt)
	}
	return offset
}

func (p *ExptStatistics) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProcessingTurnCnt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 8)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.ProcessingTurnCnt)
	}
	return offset
}

func (p *ExptStatistics) field1Length() int {
	l := 0
	if p.IsSetEvaluatorAggregateResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.EvaluatorAggregateResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ExptStatistics) field2Length() int {
	l := 0
	if p.IsSetTokenUsage() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TokenUsage.BLength()
	}
	return l
}

func (p *ExptStatistics) field3Length() int {
	l := 0
	if p.IsSetCreditCost() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *ExptStatistics) field4Length() int {
	l := 0
	if p.IsSetPendingTurnCnt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExptStatistics) field5Length() int {
	l := 0
	if p.IsSetSuccessTurnCnt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExptStatistics) field6Length() int {
	l := 0
	if p.IsSetFailTurnCnt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExptStatistics) field7Length() int {
	l := 0
	if p.IsSetTerminatedTurnCnt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExptStatistics) field8Length() int {
	l := 0
	if p.IsSetProcessingTurnCnt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExptStatistics) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptStatistics)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorAggregateResults != nil {
		p.EvaluatorAggregateResults = make([]*EvaluatorAggregateResult_, 0, len(src.EvaluatorAggregateResults))
		for _, elem := range src.EvaluatorAggregateResults {
			var _elem *EvaluatorAggregateResult_
			if elem != nil {
				_elem = &EvaluatorAggregateResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.EvaluatorAggregateResults = append(p.EvaluatorAggregateResults, _elem)
		}
	}

	var _tokenUsage *TokenUsage
	if src.TokenUsage != nil {
		_tokenUsage = &TokenUsage{}
		if err := _tokenUsage.DeepCopy(src.TokenUsage); err != nil {
			return err
		}
	}
	p.TokenUsage = _tokenUsage

	if src.CreditCost != nil {
		tmp := *src.CreditCost
		p.CreditCost = &tmp
	}

	if src.PendingTurnCnt != nil {
		tmp := *src.PendingTurnCnt
		p.PendingTurnCnt = &tmp
	}

	if src.SuccessTurnCnt != nil {
		tmp := *src.SuccessTurnCnt
		p.SuccessTurnCnt = &tmp
	}

	if src.FailTurnCnt != nil {
		tmp := *src.FailTurnCnt
		p.FailTurnCnt = &tmp
	}

	if src.TerminatedTurnCnt != nil {
		tmp := *src.TerminatedTurnCnt
		p.TerminatedTurnCnt = &tmp
	}

	if src.ProcessingTurnCnt != nil {
		tmp := *src.ProcessingTurnCnt
		p.ProcessingTurnCnt = &tmp
	}

	return nil
}

func (p *EvaluatorFmtResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_EvaluatorFmtResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *EvaluatorFmtResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *EvaluatorFmtResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Score = _field
	return offset, nil
}

func (p *EvaluatorFmtResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *EvaluatorFmtResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *EvaluatorFmtResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *EvaluatorFmtResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *EvaluatorFmtResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetScore() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 2)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.Score)
	}
	return offset
}

func (p *EvaluatorFmtResult_) field1Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *EvaluatorFmtResult_) field2Length() int {
	l := 0
	if p.IsSetScore() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *EvaluatorFmtResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*EvaluatorFmtResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Score != nil {
		tmp := *src.Score
		p.Score = &tmp
	}

	return nil
}

func (p *TargetFieldMapping) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TargetFieldMapping[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TargetFieldMapping) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldMapping, 0, size)
	values := make([]FieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FromEvalSet = _field
	return offset, nil
}

func (p *TargetFieldMapping) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TargetFieldMapping) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TargetFieldMapping) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TargetFieldMapping) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromEvalSet() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FromEvalSet {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *TargetFieldMapping) field1Length() int {
	l := 0
	if p.IsSetFromEvalSet() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FromEvalSet {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *TargetFieldMapping) DeepCopy(s interface{}) error {
	src, ok := s.(*TargetFieldMapping)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.FromEvalSet != nil {
		p.FromEvalSet = make([]*FieldMapping, 0, len(src.FromEvalSet))
		for _, elem := range src.FromEvalSet {
			var _elem *FieldMapping
			if elem != nil {
				_elem = &FieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FromEvalSet = append(p.FromEvalSet, _elem)
		}
	}

	return nil
}

func (p *EvaluatorFieldMapping) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetEvaluatorVersionID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEvaluatorVersionID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetEvaluatorVersionID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_EvaluatorFieldMapping[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_EvaluatorFieldMapping[fieldId]))
}

func (p *EvaluatorFieldMapping) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.EvaluatorVersionID = _field
	return offset, nil
}

func (p *EvaluatorFieldMapping) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldMapping, 0, size)
	values := make([]FieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FromEvalSet = _field
	return offset, nil
}

func (p *EvaluatorFieldMapping) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldMapping, 0, size)
	values := make([]FieldMapping, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FromTarget = _field
	return offset, nil
}

func (p *EvaluatorFieldMapping) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *EvaluatorFieldMapping) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *EvaluatorFieldMapping) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *EvaluatorFieldMapping) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.EvaluatorVersionID)
	return offset
}

func (p *EvaluatorFieldMapping) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromEvalSet() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FromEvalSet {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *EvaluatorFieldMapping) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromTarget() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 3)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FromTarget {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *EvaluatorFieldMapping) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *EvaluatorFieldMapping) field2Length() int {
	l := 0
	if p.IsSetFromEvalSet() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FromEvalSet {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *EvaluatorFieldMapping) field3Length() int {
	l := 0
	if p.IsSetFromTarget() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FromTarget {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *EvaluatorFieldMapping) DeepCopy(s interface{}) error {
	src, ok := s.(*EvaluatorFieldMapping)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.EvaluatorVersionID = src.EvaluatorVersionID

	if src.FromEvalSet != nil {
		p.FromEvalSet = make([]*FieldMapping, 0, len(src.FromEvalSet))
		for _, elem := range src.FromEvalSet {
			var _elem *FieldMapping
			if elem != nil {
				_elem = &FieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FromEvalSet = append(p.FromEvalSet, _elem)
		}
	}

	if src.FromTarget != nil {
		p.FromTarget = make([]*FieldMapping, 0, len(src.FromTarget))
		for _, elem := range src.FromTarget {
			var _elem *FieldMapping
			if elem != nil {
				_elem = &FieldMapping{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FromTarget = append(p.FromTarget, _elem)
		}
	}

	return nil
}

func (p *FieldMapping) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FieldMapping[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FieldMapping) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FieldName = _field
	return offset, nil
}

func (p *FieldMapping) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ConstValue = _field
	return offset, nil
}

func (p *FieldMapping) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FromFieldName = _field
	return offset, nil
}

func (p *FieldMapping) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FieldMapping) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FieldMapping) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FieldMapping) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFieldName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.FieldName)
	}
	return offset
}

func (p *FieldMapping) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetConstValue() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ConstValue)
	}
	return offset
}

func (p *FieldMapping) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFromFieldName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.FromFieldName)
	}
	return offset
}

func (p *FieldMapping) field1Length() int {
	l := 0
	if p.IsSetFieldName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.FieldName)
	}
	return l
}

func (p *FieldMapping) field2Length() int {
	l := 0
	if p.IsSetConstValue() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ConstValue)
	}
	return l
}

func (p *FieldMapping) field3Length() int {
	l := 0
	if p.IsSetFromFieldName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.FromFieldName)
	}
	return l
}

func (p *FieldMapping) DeepCopy(s interface{}) error {
	src, ok := s.(*FieldMapping)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.FieldName != nil {
		var tmp string
		if *src.FieldName != "" {
			tmp = kutils.StringDeepCopy(*src.FieldName)
		}
		p.FieldName = &tmp
	}

	if src.ConstValue != nil {
		var tmp string
		if *src.ConstValue != "" {
			tmp = kutils.StringDeepCopy(*src.ConstValue)
		}
		p.ConstValue = &tmp
	}

	if src.FromFieldName != nil {
		var tmp string
		if *src.FromFieldName != "" {
			tmp = kutils.StringDeepCopy(*src.FromFieldName)
		}
		p.FromFieldName = &tmp
	}

	return nil
}

func (p *ExptFilterOption) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptFilterOption[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExptFilterOption) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FuzzyName = _field
	return offset, nil
}

func (p *ExptFilterOption) FastReadField10(buf []byte) (int, error) {
	offset := 0
	_field := NewFilters()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Filters = _field
	return offset, nil
}

func (p *ExptFilterOption) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptFilterOption) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptFilterOption) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field10Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptFilterOption) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFuzzyName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.FuzzyName)
	}
	return offset
}

func (p *ExptFilterOption) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFilters() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 10)
		offset += p.Filters.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExptFilterOption) field1Length() int {
	l := 0
	if p.IsSetFuzzyName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.FuzzyName)
	}
	return l
}

func (p *ExptFilterOption) field10Length() int {
	l := 0
	if p.IsSetFilters() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Filters.BLength()
	}
	return l
}

func (p *ExptFilterOption) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptFilterOption)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.FuzzyName != nil {
		var tmp string
		if *src.FuzzyName != "" {
			tmp = kutils.StringDeepCopy(*src.FuzzyName)
		}
		p.FuzzyName = &tmp
	}

	var _filters *Filters
	if src.Filters != nil {
		_filters = &Filters{}
		if err := _filters.DeepCopy(src.Filters); err != nil {
			return err
		}
	}
	p.Filters = _filters

	return nil
}

func (p *ItemSystemInfo) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ItemSystemInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ItemSystemInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *ItemRunState
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ItemRunState(v)
		_field = &tmp
	}
	p.RunState = _field
	return offset, nil
}

func (p *ItemSystemInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.LogID = _field
	return offset, nil
}

func (p *ItemSystemInfo) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewRunError()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Error = _field
	return offset, nil
}

func (p *ItemSystemInfo) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ItemSystemInfo) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ItemSystemInfo) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ItemSystemInfo) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRunState() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.RunState))
	}
	return offset
}

func (p *ItemSystemInfo) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLogID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.LogID)
	}
	return offset
}

func (p *ItemSystemInfo) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetError() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.Error.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ItemSystemInfo) field1Length() int {
	l := 0
	if p.IsSetRunState() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ItemSystemInfo) field2Length() int {
	l := 0
	if p.IsSetLogID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.LogID)
	}
	return l
}

func (p *ItemSystemInfo) field3Length() int {
	l := 0
	if p.IsSetError() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Error.BLength()
	}
	return l
}

func (p *ItemSystemInfo) DeepCopy(s interface{}) error {
	src, ok := s.(*ItemSystemInfo)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.RunState != nil {
		tmp := *src.RunState
		p.RunState = &tmp
	}

	if src.LogID != nil {
		var tmp string
		if *src.LogID != "" {
			tmp = kutils.StringDeepCopy(*src.LogID)
		}
		p.LogID = &tmp
	}

	var _error *RunError
	if src.Error != nil {
		_error = &RunError{}
		if err := _error.DeepCopy(src.Error); err != nil {
			return err
		}
	}
	p.Error = _error

	return nil
}

func (p *ExptColumnEvaluator) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetExperimentID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExperimentID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetExperimentID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptColumnEvaluator[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ExptColumnEvaluator[fieldId]))
}

func (p *ExptColumnEvaluator) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ExperimentID = _field
	return offset, nil
}

func (p *ExptColumnEvaluator) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ColumnEvaluator, 0, size)
	values := make([]ColumnEvaluator, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.ColumnEvaluators = _field
	return offset, nil
}

func (p *ExptColumnEvaluator) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptColumnEvaluator) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptColumnEvaluator) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptColumnEvaluator) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ExperimentID)
	return offset
}

func (p *ExptColumnEvaluator) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetColumnEvaluators() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.ColumnEvaluators {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ExptColumnEvaluator) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExptColumnEvaluator) field2Length() int {
	l := 0
	if p.IsSetColumnEvaluators() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.ColumnEvaluators {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ExptColumnEvaluator) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptColumnEvaluator)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ExperimentID = src.ExperimentID

	if src.ColumnEvaluators != nil {
		p.ColumnEvaluators = make([]*ColumnEvaluator, 0, len(src.ColumnEvaluators))
		for _, elem := range src.ColumnEvaluators {
			var _elem *ColumnEvaluator
			if elem != nil {
				_elem = &ColumnEvaluator{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.ColumnEvaluators = append(p.ColumnEvaluators, _elem)
		}
	}

	return nil
}

func (p *ColumnEvaluator) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetEvaluatorVersionID bool = false
	var issetEvaluatorID bool = false
	var issetEvaluatorType bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEvaluatorVersionID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEvaluatorID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEvaluatorType = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetEvaluatorVersionID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetEvaluatorID {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetEvaluatorType {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ColumnEvaluator[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ColumnEvaluator[fieldId]))
}

func (p *ColumnEvaluator) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.EvaluatorVersionID = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.EvaluatorID = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field evaluator.EvaluatorType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		_field = evaluator.EvaluatorType(v)
	}
	p.EvaluatorType = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Version = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *ColumnEvaluator) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ColumnEvaluator) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ColumnEvaluator) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ColumnEvaluator) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.EvaluatorVersionID)
	return offset
}

func (p *ColumnEvaluator) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
	offset += thrift.Binary.WriteI64(buf[offset:], p.EvaluatorID)
	return offset
}

func (p *ColumnEvaluator) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 3)
	offset += thrift.Binary.WriteI32(buf[offset:], int32(p.EvaluatorType))
	return offset
}

func (p *ColumnEvaluator) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Version)
	}
	return offset
}

func (p *ColumnEvaluator) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *ColumnEvaluator) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ColumnEvaluator) field2Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ColumnEvaluator) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I32Length()
	return l
}

func (p *ColumnEvaluator) field4Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *ColumnEvaluator) field5Length() int {
	l := 0
	if p.IsSetVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Version)
	}
	return l
}

func (p *ColumnEvaluator) field6Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *ColumnEvaluator) DeepCopy(s interface{}) error {
	src, ok := s.(*ColumnEvaluator)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.EvaluatorVersionID = src.EvaluatorVersionID

	p.EvaluatorID = src.EvaluatorID

	p.EvaluatorType = src.EvaluatorType

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Version != nil {
		var tmp string
		if *src.Version != "" {
			tmp = kutils.StringDeepCopy(*src.Version)
		}
		p.Version = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	return nil
}

func (p *ColumnEvalSetField) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ColumnEvalSetField[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ColumnEvalSetField) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Key = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *common.ContentType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ContentType = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TextSchema = _field
	return offset, nil
}

func (p *ColumnEvalSetField) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ColumnEvalSetField) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ColumnEvalSetField) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field6Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ColumnEvalSetField) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Key)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ContentType)
	}
	return offset
}

func (p *ColumnEvalSetField) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTextSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TextSchema)
	}
	return offset
}

func (p *ColumnEvalSetField) field1Length() int {
	l := 0
	if p.IsSetKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Key)
	}
	return l
}

func (p *ColumnEvalSetField) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *ColumnEvalSetField) field3Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *ColumnEvalSetField) field4Length() int {
	l := 0
	if p.IsSetContentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ContentType)
	}
	return l
}

func (p *ColumnEvalSetField) field6Length() int {
	l := 0
	if p.IsSetTextSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TextSchema)
	}
	return l
}

func (p *ColumnEvalSetField) DeepCopy(s interface{}) error {
	src, ok := s.(*ColumnEvalSetField)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Key != nil {
		var tmp string
		if *src.Key != "" {
			tmp = kutils.StringDeepCopy(*src.Key)
		}
		p.Key = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.ContentType != nil {
		tmp := *src.ContentType
		p.ContentType = &tmp
	}

	if src.TextSchema != nil {
		var tmp string
		if *src.TextSchema != "" {
			tmp = kutils.StringDeepCopy(*src.TextSchema)
		}
		p.TextSchema = &tmp
	}

	return nil
}

func (p *ItemResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetItemID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetItemID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetItemID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ItemResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ItemResult_[fieldId]))
}

func (p *ItemResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ItemID = _field
	return offset, nil
}

func (p *ItemResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*TurnResult_, 0, size)
	values := make([]TurnResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.TurnResults = _field
	return offset, nil
}

func (p *ItemResult_) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewItemSystemInfo()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SystemInfo = _field
	return offset, nil
}

func (p *ItemResult_) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemIndex = _field
	return offset, nil
}

func (p *ItemResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ItemResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ItemResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ItemResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ItemID)
	return offset
}

func (p *ItemResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTurnResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.TurnResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ItemResult_) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSystemInfo() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.SystemInfo.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ItemResult_) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemIndex() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ItemIndex)
	}
	return offset
}

func (p *ItemResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ItemResult_) field2Length() int {
	l := 0
	if p.IsSetTurnResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.TurnResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ItemResult_) field3Length() int {
	l := 0
	if p.IsSetSystemInfo() {
		l += thrift.Binary.FieldBeginLength()
		l += p.SystemInfo.BLength()
	}
	return l
}

func (p *ItemResult_) field4Length() int {
	l := 0
	if p.IsSetItemIndex() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ItemResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*ItemResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ItemID = src.ItemID

	if src.TurnResults != nil {
		p.TurnResults = make([]*TurnResult_, 0, len(src.TurnResults))
		for _, elem := range src.TurnResults {
			var _elem *TurnResult_
			if elem != nil {
				_elem = &TurnResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.TurnResults = append(p.TurnResults, _elem)
		}
	}

	var _systemInfo *ItemSystemInfo
	if src.SystemInfo != nil {
		_systemInfo = &ItemSystemInfo{}
		if err := _systemInfo.DeepCopy(src.SystemInfo); err != nil {
			return err
		}
	}
	p.SystemInfo = _systemInfo

	if src.ItemIndex != nil {
		tmp := *src.ItemIndex
		p.ItemIndex = &tmp
	}

	return nil
}

func (p *TurnResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.TurnID = _field
	return offset, nil
}

func (p *TurnResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ExperimentResult_, 0, size)
	values := make([]ExperimentResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.ExperimentResults = _field
	return offset, nil
}

func (p *TurnResult_) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TurnIndex = _field
	return offset, nil
}

func (p *TurnResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.TurnID)
	return offset
}

func (p *TurnResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExperimentResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.ExperimentResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *TurnResult_) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTurnIndex() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.TurnIndex)
	}
	return offset
}

func (p *TurnResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *TurnResult_) field2Length() int {
	l := 0
	if p.IsSetExperimentResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.ExperimentResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *TurnResult_) field3Length() int {
	l := 0
	if p.IsSetTurnIndex() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *TurnResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.TurnID = src.TurnID

	if src.ExperimentResults != nil {
		p.ExperimentResults = make([]*ExperimentResult_, 0, len(src.ExperimentResults))
		for _, elem := range src.ExperimentResults {
			var _elem *ExperimentResult_
			if elem != nil {
				_elem = &ExperimentResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.ExperimentResults = append(p.ExperimentResults, _elem)
		}
	}

	if src.TurnIndex != nil {
		tmp := *src.TurnIndex
		p.TurnIndex = &tmp
	}

	return nil
}

func (p *ExperimentResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetExperimentID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExperimentID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetExperimentID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExperimentResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ExperimentResult_[fieldId]))
}

func (p *ExperimentResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ExperimentID = _field
	return offset, nil
}

func (p *ExperimentResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewExperimentTurnPayload()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Payload = _field
	return offset, nil
}

func (p *ExperimentResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExperimentResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExperimentResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExperimentResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ExperimentID)
	return offset
}

func (p *ExperimentResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetPayload() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.Payload.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExperimentResult_) field2Length() int {
	l := 0
	if p.IsSetPayload() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Payload.BLength()
	}
	return l
}

func (p *ExperimentResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*ExperimentResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ExperimentID = src.ExperimentID

	var _payload *ExperimentTurnPayload
	if src.Payload != nil {
		_payload = &ExperimentTurnPayload{}
		if err := _payload.DeepCopy(src.Payload); err != nil {
			return err
		}
	}
	p.Payload = _payload

	return nil
}

func (p *TurnSystemInfo) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnSystemInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnSystemInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *TurnRunState
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TurnRunState(v)
		_field = &tmp
	}
	p.TurnRunState = _field
	return offset, nil
}

func (p *TurnSystemInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.LogID = _field
	return offset, nil
}

func (p *TurnSystemInfo) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewRunError()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Error = _field
	return offset, nil
}

func (p *TurnSystemInfo) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnSystemInfo) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnSystemInfo) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnSystemInfo) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTurnRunState() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.TurnRunState))
	}
	return offset
}

func (p *TurnSystemInfo) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLogID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.LogID)
	}
	return offset
}

func (p *TurnSystemInfo) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetError() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.Error.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *TurnSystemInfo) field1Length() int {
	l := 0
	if p.IsSetTurnRunState() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *TurnSystemInfo) field2Length() int {
	l := 0
	if p.IsSetLogID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.LogID)
	}
	return l
}

func (p *TurnSystemInfo) field3Length() int {
	l := 0
	if p.IsSetError() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Error.BLength()
	}
	return l
}

func (p *TurnSystemInfo) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnSystemInfo)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.TurnRunState != nil {
		tmp := *src.TurnRunState
		p.TurnRunState = &tmp
	}

	if src.LogID != nil {
		var tmp string
		if *src.LogID != "" {
			tmp = kutils.StringDeepCopy(*src.LogID)
		}
		p.LogID = &tmp
	}

	var _error *RunError
	if src.Error != nil {
		_error = &RunError{}
		if err := _error.DeepCopy(src.Error); err != nil {
			return err
		}
	}
	p.Error = _error

	return nil
}

func (p *RunError) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetCode bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCode = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetCode {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_RunError[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_RunError[fieldId]))
}

func (p *RunError) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Code = _field
	return offset, nil
}

func (p *RunError) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Message = _field
	return offset, nil
}

func (p *RunError) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Detail = _field
	return offset, nil
}

func (p *RunError) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *RunError) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *RunError) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *RunError) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.Code)
	return offset
}

func (p *RunError) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMessage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Message)
	}
	return offset
}

func (p *RunError) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDetail() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Detail)
	}
	return offset
}

func (p *RunError) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *RunError) field2Length() int {
	l := 0
	if p.IsSetMessage() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Message)
	}
	return l
}

func (p *RunError) field3Length() int {
	l := 0
	if p.IsSetDetail() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Detail)
	}
	return l
}

func (p *RunError) DeepCopy(s interface{}) error {
	src, ok := s.(*RunError)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.Code = src.Code

	if src.Message != nil {
		var tmp string
		if *src.Message != "" {
			tmp = kutils.StringDeepCopy(*src.Message)
		}
		p.Message = &tmp
	}

	if src.Detail != nil {
		var tmp string
		if *src.Detail != "" {
			tmp = kutils.StringDeepCopy(*src.Detail)
		}
		p.Detail = &tmp
	}

	return nil
}

func (p *TurnEvalSet) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnEvalSet[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnEvalSet) FastReadField1(buf []byte) (int, error) {
	offset := 0
	_field := eval_set.NewTurn()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Turn = _field
	return offset, nil
}

func (p *TurnEvalSet) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnEvalSet) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnEvalSet) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnEvalSet) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 1)
	offset += p.Turn.FastWriteNocopy(buf[offset:], w)
	return offset
}

func (p *TurnEvalSet) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += p.Turn.BLength()
	return l
}

func (p *TurnEvalSet) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnEvalSet)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	var _turn *eval_set.Turn
	if src.Turn != nil {
		_turn = &eval_set.Turn{}
		if err := _turn.DeepCopy(src.Turn); err != nil {
			return err
		}
	}
	p.Turn = _turn

	return nil
}

func (p *TurnTargetOutput) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnTargetOutput[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnTargetOutput) FastReadField1(buf []byte) (int, error) {
	offset := 0
	_field := eval_target.NewEvalTargetRecord()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvalTargetRecord = _field
	return offset, nil
}

func (p *TurnTargetOutput) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnTargetOutput) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnTargetOutput) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnTargetOutput) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalTargetRecord() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 1)
		offset += p.EvalTargetRecord.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *TurnTargetOutput) field1Length() int {
	l := 0
	if p.IsSetEvalTargetRecord() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvalTargetRecord.BLength()
	}
	return l
}

func (p *TurnTargetOutput) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnTargetOutput)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	var _evalTargetRecord *eval_target.EvalTargetRecord
	if src.EvalTargetRecord != nil {
		_evalTargetRecord = &eval_target.EvalTargetRecord{}
		if err := _evalTargetRecord.DeepCopy(src.EvalTargetRecord); err != nil {
			return err
		}
	}
	p.EvalTargetRecord = _evalTargetRecord

	return nil
}

func (p *TurnEvaluatorOutput) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnEvaluatorOutput[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnEvaluatorOutput) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[int64]*evaluator.EvaluatorRecord, size)
	values := make([]evaluator.EvaluatorRecord, size)
	for i := 0; i < size; i++ {
		var _key int64
		if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.EvaluatorRecords = _field
	return offset, nil
}

func (p *TurnEvaluatorOutput) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnEvaluatorOutput) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnEvaluatorOutput) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnEvaluatorOutput) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 1)
	mapBeginOffset := offset
	offset += thrift.Binary.MapBeginLength()
	var length int
	for k, v := range p.EvaluatorRecords {
		length++
		offset += thrift.Binary.WriteI64(buf[offset:], k)
		offset += v.FastWriteNocopy(buf[offset:], w)
	}
	thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I64, thrift.STRUCT, length)
	return offset
}

func (p *TurnEvaluatorOutput) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.MapBeginLength()
	for k, v := range p.EvaluatorRecords {
		_, _ = k, v

		l += thrift.Binary.I64Length()
		l += v.BLength()
	}
	return l
}

func (p *TurnEvaluatorOutput) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnEvaluatorOutput)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvaluatorRecords != nil {
		p.EvaluatorRecords = make(map[int64]*evaluator.EvaluatorRecord, len(src.EvaluatorRecords))
		for key, val := range src.EvaluatorRecords {
			var _key int64
			_key = key

			var _val *evaluator.EvaluatorRecord
			if val != nil {
				_val = &evaluator.EvaluatorRecord{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.EvaluatorRecords[_key] = _val
		}
	}

	return nil
}

func (p *TurnAnnotateResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TurnAnnotateResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *TurnAnnotateResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[int64]*AnnotateRecord, size)
	values := make([]AnnotateRecord, size)
	for i := 0; i < size; i++ {
		var _key int64
		if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.AnnotateRecords = _field
	return offset, nil
}

func (p *TurnAnnotateResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *TurnAnnotateResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *TurnAnnotateResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *TurnAnnotateResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 1)
	mapBeginOffset := offset
	offset += thrift.Binary.MapBeginLength()
	var length int
	for k, v := range p.AnnotateRecords {
		length++
		offset += thrift.Binary.WriteI64(buf[offset:], k)
		offset += v.FastWriteNocopy(buf[offset:], w)
	}
	thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I64, thrift.STRUCT, length)
	return offset
}

func (p *TurnAnnotateResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.MapBeginLength()
	for k, v := range p.AnnotateRecords {
		_, _ = k, v

		l += thrift.Binary.I64Length()
		l += v.BLength()
	}
	return l
}

func (p *TurnAnnotateResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*TurnAnnotateResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.AnnotateRecords != nil {
		p.AnnotateRecords = make(map[int64]*AnnotateRecord, len(src.AnnotateRecords))
		for key, val := range src.AnnotateRecords {
			var _key int64
			_key = key

			var _val *AnnotateRecord
			if val != nil {
				_val = &AnnotateRecord{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.AnnotateRecords[_key] = _val
		}
	}

	return nil
}

func (p *AnnotateRecord) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AnnotateRecord[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AnnotateRecord) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AnnotateRecordID = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TagKeyID = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Score = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.BooleanOption = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CategoricalOption = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.PlainText = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *tag.TagContentType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TagContentType = _field
	return offset, nil
}

func (p *AnnotateRecord) FastReadField8(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TagValueID = _field
	return offset, nil
}

func (p *AnnotateRecord) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AnnotateRecord) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AnnotateRecord) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AnnotateRecord) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAnnotateRecordID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.AnnotateRecordID)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTagKeyID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.TagKeyID)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetScore() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Score)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBooleanOption() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.BooleanOption)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCategoricalOption() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CategoricalOption)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetPlainText() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.PlainText)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTagContentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 7)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TagContentType)
	}
	return offset
}

func (p *AnnotateRecord) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTagValueID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 8)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.TagValueID)
	}
	return offset
}

func (p *AnnotateRecord) field1Length() int {
	l := 0
	if p.IsSetAnnotateRecordID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *AnnotateRecord) field2Length() int {
	l := 0
	if p.IsSetTagKeyID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *AnnotateRecord) field3Length() int {
	l := 0
	if p.IsSetScore() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Score)
	}
	return l
}

func (p *AnnotateRecord) field4Length() int {
	l := 0
	if p.IsSetBooleanOption() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.BooleanOption)
	}
	return l
}

func (p *AnnotateRecord) field5Length() int {
	l := 0
	if p.IsSetCategoricalOption() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CategoricalOption)
	}
	return l
}

func (p *AnnotateRecord) field6Length() int {
	l := 0
	if p.IsSetPlainText() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.PlainText)
	}
	return l
}

func (p *AnnotateRecord) field7Length() int {
	l := 0
	if p.IsSetTagContentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TagContentType)
	}
	return l
}

func (p *AnnotateRecord) field8Length() int {
	l := 0
	if p.IsSetTagValueID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *AnnotateRecord) DeepCopy(s interface{}) error {
	src, ok := s.(*AnnotateRecord)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.AnnotateRecordID != nil {
		tmp := *src.AnnotateRecordID
		p.AnnotateRecordID = &tmp
	}

	if src.TagKeyID != nil {
		tmp := *src.TagKeyID
		p.TagKeyID = &tmp
	}

	if src.Score != nil {
		var tmp string
		if *src.Score != "" {
			tmp = kutils.StringDeepCopy(*src.Score)
		}
		p.Score = &tmp
	}

	if src.BooleanOption != nil {
		var tmp string
		if *src.BooleanOption != "" {
			tmp = kutils.StringDeepCopy(*src.BooleanOption)
		}
		p.BooleanOption = &tmp
	}

	if src.CategoricalOption != nil {
		var tmp string
		if *src.CategoricalOption != "" {
			tmp = kutils.StringDeepCopy(*src.CategoricalOption)
		}
		p.CategoricalOption = &tmp
	}

	if src.PlainText != nil {
		var tmp string
		if *src.PlainText != "" {
			tmp = kutils.StringDeepCopy(*src.PlainText)
		}
		p.PlainText = &tmp
	}

	if src.TagContentType != nil {
		tmp := *src.TagContentType
		p.TagContentType = &tmp
	}

	if src.TagValueID != nil {
		tmp := *src.TagValueID
		p.TagValueID = &tmp
	}

	return nil
}

func (p *ExperimentTurnPayload) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExperimentTurnPayload[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExperimentTurnPayload) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.TurnID = _field
	return offset, nil
}

func (p *ExperimentTurnPayload) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewTurnEvalSet()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvalSet = _field
	return offset, nil
}

func (p *ExperimentTurnPayload) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewTurnTargetOutput()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TargetOutput = _field
	return offset, nil
}

func (p *ExperimentTurnPayload) FastReadField4(buf []byte) (int, error) {
	offset := 0
	_field := NewTurnEvaluatorOutput()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EvaluatorOutput = _field
	return offset, nil
}

func (p *ExperimentTurnPayload) FastReadField5(buf []byte) (int, error) {
	offset := 0
	_field := NewTurnSystemInfo()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SystemInfo = _field
	return offset, nil
}

func (p *ExperimentTurnPayload) FastReadField6(buf []byte) (int, error) {
	offset := 0
	_field := NewTurnAnnotateResult_()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AnnotateResult_ = _field
	return offset, nil
}

func (p *ExperimentTurnPayload) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExperimentTurnPayload) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExperimentTurnPayload) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExperimentTurnPayload) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.TurnID)
	return offset
}

func (p *ExperimentTurnPayload) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalSet() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.EvalSet.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentTurnPayload) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTargetOutput() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.TargetOutput.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentTurnPayload) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorOutput() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 4)
		offset += p.EvaluatorOutput.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentTurnPayload) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSystemInfo() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 5)
		offset += p.SystemInfo.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentTurnPayload) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAnnotateResult_() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 6)
		offset += p.AnnotateResult_.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentTurnPayload) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExperimentTurnPayload) field2Length() int {
	l := 0
	if p.IsSetEvalSet() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvalSet.BLength()
	}
	return l
}

func (p *ExperimentTurnPayload) field3Length() int {
	l := 0
	if p.IsSetTargetOutput() {
		l += thrift.Binary.FieldBeginLength()
		l += p.TargetOutput.BLength()
	}
	return l
}

func (p *ExperimentTurnPayload) field4Length() int {
	l := 0
	if p.IsSetEvaluatorOutput() {
		l += thrift.Binary.FieldBeginLength()
		l += p.EvaluatorOutput.BLength()
	}
	return l
}

func (p *ExperimentTurnPayload) field5Length() int {
	l := 0
	if p.IsSetSystemInfo() {
		l += thrift.Binary.FieldBeginLength()
		l += p.SystemInfo.BLength()
	}
	return l
}

func (p *ExperimentTurnPayload) field6Length() int {
	l := 0
	if p.IsSetAnnotateResult_() {
		l += thrift.Binary.FieldBeginLength()
		l += p.AnnotateResult_.BLength()
	}
	return l
}

func (p *ExperimentTurnPayload) DeepCopy(s interface{}) error {
	src, ok := s.(*ExperimentTurnPayload)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.TurnID = src.TurnID

	var _evalSet *TurnEvalSet
	if src.EvalSet != nil {
		_evalSet = &TurnEvalSet{}
		if err := _evalSet.DeepCopy(src.EvalSet); err != nil {
			return err
		}
	}
	p.EvalSet = _evalSet

	var _targetOutput *TurnTargetOutput
	if src.TargetOutput != nil {
		_targetOutput = &TurnTargetOutput{}
		if err := _targetOutput.DeepCopy(src.TargetOutput); err != nil {
			return err
		}
	}
	p.TargetOutput = _targetOutput

	var _evaluatorOutput *TurnEvaluatorOutput
	if src.EvaluatorOutput != nil {
		_evaluatorOutput = &TurnEvaluatorOutput{}
		if err := _evaluatorOutput.DeepCopy(src.EvaluatorOutput); err != nil {
			return err
		}
	}
	p.EvaluatorOutput = _evaluatorOutput

	var _systemInfo *TurnSystemInfo
	if src.SystemInfo != nil {
		_systemInfo = &TurnSystemInfo{}
		if err := _systemInfo.DeepCopy(src.SystemInfo); err != nil {
			return err
		}
	}
	p.SystemInfo = _systemInfo

	var _annotateResult_ *TurnAnnotateResult_
	if src.AnnotateResult_ != nil {
		_annotateResult_ = &TurnAnnotateResult_{}
		if err := _annotateResult_.DeepCopy(src.AnnotateResult_); err != nil {
			return err
		}
	}
	p.AnnotateResult_ = _annotateResult_

	return nil
}

func (p *KeywordSearch) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_KeywordSearch[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *KeywordSearch) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Keyword = _field
	return offset, nil
}

func (p *KeywordSearch) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FilterField, 0, size)
	values := make([]FilterField, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FilterFields = _field
	return offset, nil
}

func (p *KeywordSearch) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *KeywordSearch) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *KeywordSearch) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *KeywordSearch) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKeyword() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Keyword)
	}
	return offset
}

func (p *KeywordSearch) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFilterFields() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FilterFields {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *KeywordSearch) field1Length() int {
	l := 0
	if p.IsSetKeyword() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Keyword)
	}
	return l
}

func (p *KeywordSearch) field2Length() int {
	l := 0
	if p.IsSetFilterFields() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FilterFields {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *KeywordSearch) DeepCopy(s interface{}) error {
	src, ok := s.(*KeywordSearch)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Keyword != nil {
		var tmp string
		if *src.Keyword != "" {
			tmp = kutils.StringDeepCopy(*src.Keyword)
		}
		p.Keyword = &tmp
	}

	if src.FilterFields != nil {
		p.FilterFields = make([]*FilterField, 0, len(src.FilterFields))
		for _, elem := range src.FilterFields {
			var _elem *FilterField
			if elem != nil {
				_elem = &FilterField{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FilterFields = append(p.FilterFields, _elem)
		}
	}

	return nil
}

func (p *ExperimentFilter) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExperimentFilter[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExperimentFilter) FastReadField1(buf []byte) (int, error) {
	offset := 0
	_field := NewFilters()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Filters = _field
	return offset, nil
}

func (p *ExperimentFilter) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewKeywordSearch()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.KeywordSearch = _field
	return offset, nil
}

func (p *ExperimentFilter) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExperimentFilter) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExperimentFilter) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExperimentFilter) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFilters() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 1)
		offset += p.Filters.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentFilter) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKeywordSearch() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.KeywordSearch.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExperimentFilter) field1Length() int {
	l := 0
	if p.IsSetFilters() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Filters.BLength()
	}
	return l
}

func (p *ExperimentFilter) field2Length() int {
	l := 0
	if p.IsSetKeywordSearch() {
		l += thrift.Binary.FieldBeginLength()
		l += p.KeywordSearch.BLength()
	}
	return l
}

func (p *ExperimentFilter) DeepCopy(s interface{}) error {
	src, ok := s.(*ExperimentFilter)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	var _filters *Filters
	if src.Filters != nil {
		_filters = &Filters{}
		if err := _filters.DeepCopy(src.Filters); err != nil {
			return err
		}
	}
	p.Filters = _filters

	var _keywordSearch *KeywordSearch
	if src.KeywordSearch != nil {
		_keywordSearch = &KeywordSearch{}
		if err := _keywordSearch.DeepCopy(src.KeywordSearch); err != nil {
			return err
		}
	}
	p.KeywordSearch = _keywordSearch

	return nil
}

func (p *Filters) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Filters[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *Filters) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FilterCondition, 0, size)
	values := make([]FilterCondition, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.FilterConditions = _field
	return offset, nil
}

func (p *Filters) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *FilterLogicOp
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := FilterLogicOp(v)
		_field = &tmp
	}
	p.LogicOp = _field
	return offset, nil
}

func (p *Filters) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Filters) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Filters) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Filters) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFilterConditions() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.FilterConditions {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *Filters) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLogicOp() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.LogicOp))
	}
	return offset
}

func (p *Filters) field1Length() int {
	l := 0
	if p.IsSetFilterConditions() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.FilterConditions {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *Filters) field2Length() int {
	l := 0
	if p.IsSetLogicOp() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Filters) DeepCopy(s interface{}) error {
	src, ok := s.(*Filters)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.FilterConditions != nil {
		p.FilterConditions = make([]*FilterCondition, 0, len(src.FilterConditions))
		for _, elem := range src.FilterConditions {
			var _elem *FilterCondition
			if elem != nil {
				_elem = &FilterCondition{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.FilterConditions = append(p.FilterConditions, _elem)
		}
	}

	if src.LogicOp != nil {
		tmp := *src.LogicOp
		p.LogicOp = &tmp
	}

	return nil
}

func (p *FilterField) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFieldType bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFieldType = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetFieldType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FilterField[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_FilterField[fieldId]))
}

func (p *FilterField) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field FieldType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		_field = FieldType(v)
	}
	p.FieldType = _field
	return offset, nil
}

func (p *FilterField) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FieldKey = _field
	return offset, nil
}

func (p *FilterField) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FilterField) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FilterField) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FilterField) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
	offset += thrift.Binary.WriteI32(buf[offset:], int32(p.FieldType))
	return offset
}

func (p *FilterField) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFieldKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.FieldKey)
	}
	return offset
}

func (p *FilterField) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I32Length()
	return l
}

func (p *FilterField) field2Length() int {
	l := 0
	if p.IsSetFieldKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.FieldKey)
	}
	return l
}

func (p *FilterField) DeepCopy(s interface{}) error {
	src, ok := s.(*FilterField)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.FieldType = src.FieldType

	if src.FieldKey != nil {
		var tmp string
		if *src.FieldKey != "" {
			tmp = kutils.StringDeepCopy(*src.FieldKey)
		}
		p.FieldKey = &tmp
	}

	return nil
}

func (p *FilterCondition) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FilterCondition[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FilterCondition) FastReadField1(buf []byte) (int, error) {
	offset := 0
	_field := NewFilterField()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Field = _field
	return offset, nil
}

func (p *FilterCondition) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field FilterOperatorType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		_field = FilterOperatorType(v)
	}
	p.Operator = _field
	return offset, nil
}

func (p *FilterCondition) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Value = _field
	return offset, nil
}

func (p *FilterCondition) FastReadField4(buf []byte) (int, error) {
	offset := 0
	_field := NewSourceTarget()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SourceTarget = _field
	return offset, nil
}

func (p *FilterCondition) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FilterCondition) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FilterCondition) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FilterCondition) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 1)
	offset += p.Field.FastWriteNocopy(buf[offset:], w)
	return offset
}

func (p *FilterCondition) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
	offset += thrift.Binary.WriteI32(buf[offset:], int32(p.Operator))
	return offset
}

func (p *FilterCondition) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
	offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, p.Value)
	return offset
}

func (p *FilterCondition) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSourceTarget() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 4)
		offset += p.SourceTarget.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *FilterCondition) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += p.Field.BLength()
	return l
}

func (p *FilterCondition) field2Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I32Length()
	return l
}

func (p *FilterCondition) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.StringLengthNocopy(p.Value)
	return l
}

func (p *FilterCondition) field4Length() int {
	l := 0
	if p.IsSetSourceTarget() {
		l += thrift.Binary.FieldBeginLength()
		l += p.SourceTarget.BLength()
	}
	return l
}

func (p *FilterCondition) DeepCopy(s interface{}) error {
	src, ok := s.(*FilterCondition)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	var _field *FilterField
	if src.Field != nil {
		_field = &FilterField{}
		if err := _field.DeepCopy(src.Field); err != nil {
			return err
		}
	}
	p.Field = _field

	p.Operator = src.Operator

	if src.Value != "" {
		p.Value = kutils.StringDeepCopy(src.Value)
	}

	var _sourceTarget *SourceTarget
	if src.SourceTarget != nil {
		_sourceTarget = &SourceTarget{}
		if err := _sourceTarget.DeepCopy(src.SourceTarget); err != nil {
			return err
		}
	}
	p.SourceTarget = _sourceTarget

	return nil
}

func (p *SourceTarget) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_SourceTarget[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *SourceTarget) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *eval_target.EvalTargetType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := eval_target.EvalTargetType(v)
		_field = &tmp
	}
	p.EvalTargetType = _field
	return offset, nil
}

func (p *SourceTarget) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_elem = v
		}

		_field = append(_field, _elem)
	}
	p.SourceTargetIds = _field
	return offset, nil
}

func (p *SourceTarget) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *SourceTarget) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *SourceTarget) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *SourceTarget) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvalTargetType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.EvalTargetType))
	}
	return offset
}

func (p *SourceTarget) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSourceTargetIds() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 3)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.SourceTargetIds {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, v)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	}
	return offset
}

func (p *SourceTarget) field1Length() int {
	l := 0
	if p.IsSetEvalTargetType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *SourceTarget) field3Length() int {
	l := 0
	if p.IsSetSourceTargetIds() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.SourceTargetIds {
			_ = v
			l += thrift.Binary.StringLengthNocopy(v)
		}
	}
	return l
}

func (p *SourceTarget) DeepCopy(s interface{}) error {
	src, ok := s.(*SourceTarget)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EvalTargetType != nil {
		tmp := *src.EvalTargetType
		p.EvalTargetType = &tmp
	}

	if src.SourceTargetIds != nil {
		p.SourceTargetIds = make([]string, 0, len(src.SourceTargetIds))
		for _, elem := range src.SourceTargetIds {
			var _elem string
			if elem != "" {
				_elem = kutils.StringDeepCopy(elem)
			}
			p.SourceTargetIds = append(p.SourceTargetIds, _elem)
		}
	}

	return nil
}

func (p *ExptAggregateResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetExperimentID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExperimentID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetExperimentID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptAggregateResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ExptAggregateResult_[fieldId]))
}

func (p *ExptAggregateResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ExperimentID = _field
	return offset, nil
}

func (p *ExptAggregateResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[int64]*EvaluatorAggregateResult_, size)
	values := make([]EvaluatorAggregateResult_, size)
	for i := 0; i < size; i++ {
		var _key int64
		if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.EvaluatorResults = _field
	return offset, nil
}

func (p *ExptAggregateResult_) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *ExptAggregateCalculateStatus
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ExptAggregateCalculateStatus(v)
		_field = &tmp
	}
	p.Status = _field
	return offset, nil
}

func (p *ExptAggregateResult_) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[int64]*AnnotationAggregateResult_, size)
	values := make([]AnnotationAggregateResult_, size)
	for i := 0; i < size; i++ {
		var _key int64
		if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.AnnotationResults = _field
	return offset, nil
}

func (p *ExptAggregateResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptAggregateResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptAggregateResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptAggregateResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ExperimentID)
	return offset
}

func (p *ExptAggregateResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEvaluatorResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 2)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.EvaluatorResults {
			length++
			offset += thrift.Binary.WriteI64(buf[offset:], k)
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I64, thrift.STRUCT, length)
	}
	return offset
}

func (p *ExptAggregateResult_) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 3)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Status))
	}
	return offset
}

func (p *ExptAggregateResult_) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAnnotationResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 4)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.AnnotationResults {
			length++
			offset += thrift.Binary.WriteI64(buf[offset:], k)
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I64, thrift.STRUCT, length)
	}
	return offset
}

func (p *ExptAggregateResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExptAggregateResult_) field2Length() int {
	l := 0
	if p.IsSetEvaluatorResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.EvaluatorResults {
			_, _ = k, v

			l += thrift.Binary.I64Length()
			l += v.BLength()
		}
	}
	return l
}

func (p *ExptAggregateResult_) field3Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ExptAggregateResult_) field4Length() int {
	l := 0
	if p.IsSetAnnotationResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.AnnotationResults {
			_, _ = k, v

			l += thrift.Binary.I64Length()
			l += v.BLength()
		}
	}
	return l
}

func (p *ExptAggregateResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptAggregateResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ExperimentID = src.ExperimentID

	if src.EvaluatorResults != nil {
		p.EvaluatorResults = make(map[int64]*EvaluatorAggregateResult_, len(src.EvaluatorResults))
		for key, val := range src.EvaluatorResults {
			var _key int64
			_key = key

			var _val *EvaluatorAggregateResult_
			if val != nil {
				_val = &EvaluatorAggregateResult_{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.EvaluatorResults[_key] = _val
		}
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.AnnotationResults != nil {
		p.AnnotationResults = make(map[int64]*AnnotationAggregateResult_, len(src.AnnotationResults))
		for key, val := range src.AnnotationResults {
			var _key int64
			_key = key

			var _val *AnnotationAggregateResult_
			if val != nil {
				_val = &AnnotationAggregateResult_{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.AnnotationResults[_key] = _val
		}
	}

	return nil
}

func (p *EvaluatorAggregateResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetEvaluatorVersionID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEvaluatorVersionID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetEvaluatorVersionID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_EvaluatorAggregateResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_EvaluatorAggregateResult_[fieldId]))
}

func (p *EvaluatorAggregateResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.EvaluatorVersionID = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*AggregatorResult_, 0, size)
	values := make([]AggregatorResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.AggregatorResults = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Version = _field
	return offset, nil
}

func (p *EvaluatorAggregateResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *EvaluatorAggregateResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *EvaluatorAggregateResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *EvaluatorAggregateResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.EvaluatorVersionID)
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAggregatorResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.AggregatorResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Version)
	}
	return offset
}

func (p *EvaluatorAggregateResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *EvaluatorAggregateResult_) field2Length() int {
	l := 0
	if p.IsSetAggregatorResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.AggregatorResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *EvaluatorAggregateResult_) field3Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *EvaluatorAggregateResult_) field4Length() int {
	l := 0
	if p.IsSetVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Version)
	}
	return l
}

func (p *EvaluatorAggregateResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*EvaluatorAggregateResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.EvaluatorVersionID = src.EvaluatorVersionID

	if src.AggregatorResults != nil {
		p.AggregatorResults = make([]*AggregatorResult_, 0, len(src.AggregatorResults))
		for _, elem := range src.AggregatorResults {
			var _elem *AggregatorResult_
			if elem != nil {
				_elem = &AggregatorResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.AggregatorResults = append(p.AggregatorResults, _elem)
		}
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Version != nil {
		var tmp string
		if *src.Version != "" {
			tmp = kutils.StringDeepCopy(*src.Version)
		}
		p.Version = &tmp
	}

	return nil
}

func (p *AnnotationAggregateResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTagKeyID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTagKeyID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetTagKeyID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AnnotationAggregateResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_AnnotationAggregateResult_[fieldId]))
}

func (p *AnnotationAggregateResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.TagKeyID = _field
	return offset, nil
}

func (p *AnnotationAggregateResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*AggregatorResult_, 0, size)
	values := make([]AggregatorResult_, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.AggregatorResults = _field
	return offset, nil
}

func (p *AnnotationAggregateResult_) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *AnnotationAggregateResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AnnotationAggregateResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AnnotationAggregateResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AnnotationAggregateResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.TagKeyID)
	return offset
}

func (p *AnnotationAggregateResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAggregatorResults() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.AggregatorResults {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *AnnotationAggregateResult_) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *AnnotationAggregateResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *AnnotationAggregateResult_) field2Length() int {
	l := 0
	if p.IsSetAggregatorResults() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.AggregatorResults {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *AnnotationAggregateResult_) field3Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *AnnotationAggregateResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*AnnotationAggregateResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.TagKeyID = src.TagKeyID

	if src.AggregatorResults != nil {
		p.AggregatorResults = make([]*AggregatorResult_, 0, len(src.AggregatorResults))
		for _, elem := range src.AggregatorResults {
			var _elem *AggregatorResult_
			if elem != nil {
				_elem = &AggregatorResult_{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.AggregatorResults = append(p.AggregatorResults, _elem)
		}
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	return nil
}

func (p *AggregatorResult_) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetAggregatorType bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetAggregatorType = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetAggregatorType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AggregatorResult_[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_AggregatorResult_[fieldId]))
}

func (p *AggregatorResult_) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field AggregatorType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		_field = AggregatorType(v)
	}
	p.AggregatorType = _field
	return offset, nil
}

func (p *AggregatorResult_) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewAggregateData()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Data = _field
	return offset, nil
}

func (p *AggregatorResult_) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AggregatorResult_) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AggregatorResult_) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AggregatorResult_) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
	offset += thrift.Binary.WriteI32(buf[offset:], int32(p.AggregatorType))
	return offset
}

func (p *AggregatorResult_) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetData() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.Data.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AggregatorResult_) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I32Length()
	return l
}

func (p *AggregatorResult_) field2Length() int {
	l := 0
	if p.IsSetData() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Data.BLength()
	}
	return l
}

func (p *AggregatorResult_) DeepCopy(s interface{}) error {
	src, ok := s.(*AggregatorResult_)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.AggregatorType = src.AggregatorType

	var _data *AggregateData
	if src.Data != nil {
		_data = &AggregateData{}
		if err := _data.DeepCopy(src.Data); err != nil {
			return err
		}
	}
	p.Data = _data

	return nil
}

func (p *ScoreDistribution) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ScoreDistribution[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ScoreDistribution) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ScoreDistributionItem, 0, size)
	values := make([]ScoreDistributionItem, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.ScoreDistributionItems = _field
	return offset, nil
}

func (p *ScoreDistribution) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ScoreDistribution) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ScoreDistribution) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ScoreDistribution) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetScoreDistributionItems() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.ScoreDistributionItems {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ScoreDistribution) field1Length() int {
	l := 0
	if p.IsSetScoreDistributionItems() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.ScoreDistributionItems {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ScoreDistribution) DeepCopy(s interface{}) error {
	src, ok := s.(*ScoreDistribution)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ScoreDistributionItems != nil {
		p.ScoreDistributionItems = make([]*ScoreDistributionItem, 0, len(src.ScoreDistributionItems))
		for _, elem := range src.ScoreDistributionItems {
			var _elem *ScoreDistributionItem
			if elem != nil {
				_elem = &ScoreDistributionItem{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.ScoreDistributionItems = append(p.ScoreDistributionItems, _elem)
		}
	}

	return nil
}

func (p *ScoreDistributionItem) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetScore bool = false
	var issetCount bool = false
	var issetPercentage bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetScore = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCount = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPercentage = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetScore {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetCount {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetPercentage {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ScoreDistributionItem[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ScoreDistributionItem[fieldId]))
}

func (p *ScoreDistributionItem) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Score = _field
	return offset, nil
}

func (p *ScoreDistributionItem) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Count = _field
	return offset, nil
}

func (p *ScoreDistributionItem) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Percentage = _field
	return offset, nil
}

func (p *ScoreDistributionItem) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ScoreDistributionItem) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ScoreDistributionItem) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ScoreDistributionItem) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
	offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, p.Score)
	return offset
}

func (p *ScoreDistributionItem) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
	offset += thrift.Binary.WriteI64(buf[offset:], p.Count)
	return offset
}

func (p *ScoreDistributionItem) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 3)
	offset += thrift.Binary.WriteDouble(buf[offset:], p.Percentage)
	return offset
}

func (p *ScoreDistributionItem) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.StringLengthNocopy(p.Score)
	return l
}

func (p *ScoreDistributionItem) field2Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ScoreDistributionItem) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.DoubleLength()
	return l
}

func (p *ScoreDistributionItem) DeepCopy(s interface{}) error {
	src, ok := s.(*ScoreDistributionItem)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Score != "" {
		p.Score = kutils.StringDeepCopy(src.Score)
	}

	p.Count = src.Count

	p.Percentage = src.Percentage

	return nil
}

func (p *AggregateData) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDataType bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDataType = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetDataType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AggregateData[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_AggregateData[fieldId]))
}

func (p *AggregateData) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field DataType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		_field = DataType(v)
	}
	p.DataType = _field
	return offset, nil
}

func (p *AggregateData) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Value = _field
	return offset, nil
}

func (p *AggregateData) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewScoreDistribution()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ScoreDistribution = _field
	return offset, nil
}

func (p *AggregateData) FastReadField4(buf []byte) (int, error) {
	offset := 0
	_field := NewOptionDistribution()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OptionDistribution = _field
	return offset, nil
}

func (p *AggregateData) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AggregateData) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AggregateData) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AggregateData) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
	offset += thrift.Binary.WriteI32(buf[offset:], int32(p.DataType))
	return offset
}

func (p *AggregateData) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetValue() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 2)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.Value)
	}
	return offset
}

func (p *AggregateData) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetScoreDistribution() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.ScoreDistribution.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AggregateData) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOptionDistribution() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 4)
		offset += p.OptionDistribution.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AggregateData) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I32Length()
	return l
}

func (p *AggregateData) field2Length() int {
	l := 0
	if p.IsSetValue() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *AggregateData) field3Length() int {
	l := 0
	if p.IsSetScoreDistribution() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ScoreDistribution.BLength()
	}
	return l
}

func (p *AggregateData) field4Length() int {
	l := 0
	if p.IsSetOptionDistribution() {
		l += thrift.Binary.FieldBeginLength()
		l += p.OptionDistribution.BLength()
	}
	return l
}

func (p *AggregateData) DeepCopy(s interface{}) error {
	src, ok := s.(*AggregateData)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.DataType = src.DataType

	if src.Value != nil {
		tmp := *src.Value
		p.Value = &tmp
	}

	var _scoreDistribution *ScoreDistribution
	if src.ScoreDistribution != nil {
		_scoreDistribution = &ScoreDistribution{}
		if err := _scoreDistribution.DeepCopy(src.ScoreDistribution); err != nil {
			return err
		}
	}
	p.ScoreDistribution = _scoreDistribution

	var _optionDistribution *OptionDistribution
	if src.OptionDistribution != nil {
		_optionDistribution = &OptionDistribution{}
		if err := _optionDistribution.DeepCopy(src.OptionDistribution); err != nil {
			return err
		}
	}
	p.OptionDistribution = _optionDistribution

	return nil
}

func (p *OptionDistribution) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_OptionDistribution[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *OptionDistribution) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*OptionDistributionItem, 0, size)
	values := make([]OptionDistributionItem, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.OptionDistributionItems = _field
	return offset, nil
}

func (p *OptionDistribution) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *OptionDistribution) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *OptionDistribution) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *OptionDistribution) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOptionDistributionItems() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.OptionDistributionItems {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *OptionDistribution) field1Length() int {
	l := 0
	if p.IsSetOptionDistributionItems() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.OptionDistributionItems {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *OptionDistribution) DeepCopy(s interface{}) error {
	src, ok := s.(*OptionDistribution)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.OptionDistributionItems != nil {
		p.OptionDistributionItems = make([]*OptionDistributionItem, 0, len(src.OptionDistributionItems))
		for _, elem := range src.OptionDistributionItems {
			var _elem *OptionDistributionItem
			if elem != nil {
				_elem = &OptionDistributionItem{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.OptionDistributionItems = append(p.OptionDistributionItems, _elem)
		}
	}

	return nil
}

func (p *OptionDistributionItem) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetOption bool = false
	var issetCount bool = false
	var issetPercentage bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOption = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCount = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPercentage = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetOption {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetCount {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetPercentage {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_OptionDistributionItem[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_OptionDistributionItem[fieldId]))
}

func (p *OptionDistributionItem) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Option = _field
	return offset, nil
}

func (p *OptionDistributionItem) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Count = _field
	return offset, nil
}

func (p *OptionDistributionItem) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.Percentage = _field
	return offset, nil
}

func (p *OptionDistributionItem) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *OptionDistributionItem) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *OptionDistributionItem) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *OptionDistributionItem) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
	offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, p.Option)
	return offset
}

func (p *OptionDistributionItem) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
	offset += thrift.Binary.WriteI64(buf[offset:], p.Count)
	return offset
}

func (p *OptionDistributionItem) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 3)
	offset += thrift.Binary.WriteDouble(buf[offset:], p.Percentage)
	return offset
}

func (p *OptionDistributionItem) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.StringLengthNocopy(p.Option)
	return l
}

func (p *OptionDistributionItem) field2Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *OptionDistributionItem) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.DoubleLength()
	return l
}

func (p *OptionDistributionItem) DeepCopy(s interface{}) error {
	src, ok := s.(*OptionDistributionItem)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Option != "" {
		p.Option = kutils.StringDeepCopy(src.Option)
	}

	p.Count = src.Count

	p.Percentage = src.Percentage

	return nil
}

func (p *ExptStatsInfo) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptStatsInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ExptStatsInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ExptID = _field
	return offset, nil
}

func (p *ExptStatsInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SourceID = _field
	return offset, nil
}

func (p *ExptStatsInfo) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewExptStatistics()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExptStats = _field
	return offset, nil
}

func (p *ExptStatsInfo) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptStatsInfo) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptStatsInfo) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptStatsInfo) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExptID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ExptID)
	}
	return offset
}

func (p *ExptStatsInfo) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSourceID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SourceID)
	}
	return offset
}

func (p *ExptStatsInfo) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExptStats() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.ExptStats.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExptStatsInfo) field1Length() int {
	l := 0
	if p.IsSetExptID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ExptStatsInfo) field2Length() int {
	l := 0
	if p.IsSetSourceID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SourceID)
	}
	return l
}

func (p *ExptStatsInfo) field3Length() int {
	l := 0
	if p.IsSetExptStats() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ExptStats.BLength()
	}
	return l
}

func (p *ExptStatsInfo) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptStatsInfo)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ExptID != nil {
		tmp := *src.ExptID
		p.ExptID = &tmp
	}

	if src.SourceID != nil {
		var tmp string
		if *src.SourceID != "" {
			tmp = kutils.StringDeepCopy(*src.SourceID)
		}
		p.SourceID = &tmp
	}

	var _exptStats *ExptStatistics
	if src.ExptStats != nil {
		_exptStats = &ExptStatistics{}
		if err := _exptStats.DeepCopy(src.ExptStats); err != nil {
			return err
		}
	}
	p.ExptStats = _exptStats

	return nil
}

func (p *ExptColumnAnnotation) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetExperimentID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExperimentID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetExperimentID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptColumnAnnotation[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ExptColumnAnnotation[fieldId]))
}

func (p *ExptColumnAnnotation) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ExperimentID = _field
	return offset, nil
}

func (p *ExptColumnAnnotation) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ColumnAnnotation, 0, size)
	values := make([]ColumnAnnotation, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.ColumnAnnotations = _field
	return offset, nil
}

func (p *ExptColumnAnnotation) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptColumnAnnotation) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptColumnAnnotation) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptColumnAnnotation) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ExperimentID)
	return offset
}

func (p *ExptColumnAnnotation) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetColumnAnnotations() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.ColumnAnnotations {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ExptColumnAnnotation) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExptColumnAnnotation) field2Length() int {
	l := 0
	if p.IsSetColumnAnnotations() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.ColumnAnnotations {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ExptColumnAnnotation) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptColumnAnnotation)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ExperimentID = src.ExperimentID

	if src.ColumnAnnotations != nil {
		p.ColumnAnnotations = make([]*ColumnAnnotation, 0, len(src.ColumnAnnotations))
		for _, elem := range src.ColumnAnnotations {
			var _elem *ColumnAnnotation
			if elem != nil {
				_elem = &ColumnAnnotation{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.ColumnAnnotations = append(p.ColumnAnnotations, _elem)
		}
	}

	return nil
}

func (p *ColumnAnnotation) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ColumnAnnotation[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ColumnAnnotation) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TagKeyID = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TagKeyName = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *tag.TagStatus
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Status = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastReadField13(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*tag.TagValue, 0, size)
	values := make([]tag.TagValue, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.TagValues = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastReadField14(buf []byte) (int, error) {
	offset := 0

	var _field *tag.TagContentType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ContentType = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastReadField15(buf []byte) (int, error) {
	offset := 0
	_field := tag.NewTagContentSpec()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ContentSpec = _field
	return offset, nil
}

func (p *ColumnAnnotation) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ColumnAnnotation) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField13(buf[offset:], w)
		offset += p.fastWriteField14(buf[offset:], w)
		offset += p.fastWriteField15(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ColumnAnnotation) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ColumnAnnotation) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTagKeyID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.TagKeyID)
	}
	return offset
}

func (p *ColumnAnnotation) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTagKeyName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TagKeyName)
	}
	return offset
}

func (p *ColumnAnnotation) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *ColumnAnnotation) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Status)
	}
	return offset
}

func (p *ColumnAnnotation) fastWriteField13(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTagValues() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 13)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.TagValues {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ColumnAnnotation) fastWriteField14(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 14)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ContentType)
	}
	return offset
}

func (p *ColumnAnnotation) fastWriteField15(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContentSpec() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 15)
		offset += p.ContentSpec.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ColumnAnnotation) field1Length() int {
	l := 0
	if p.IsSetTagKeyID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ColumnAnnotation) field2Length() int {
	l := 0
	if p.IsSetTagKeyName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TagKeyName)
	}
	return l
}

func (p *ColumnAnnotation) field3Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *ColumnAnnotation) field4Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Status)
	}
	return l
}

func (p *ColumnAnnotation) field13Length() int {
	l := 0
	if p.IsSetTagValues() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.TagValues {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ColumnAnnotation) field14Length() int {
	l := 0
	if p.IsSetContentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ContentType)
	}
	return l
}

func (p *ColumnAnnotation) field15Length() int {
	l := 0
	if p.IsSetContentSpec() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ContentSpec.BLength()
	}
	return l
}

func (p *ColumnAnnotation) DeepCopy(s interface{}) error {
	src, ok := s.(*ColumnAnnotation)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.TagKeyID != nil {
		tmp := *src.TagKeyID
		p.TagKeyID = &tmp
	}

	if src.TagKeyName != nil {
		var tmp string
		if *src.TagKeyName != "" {
			tmp = kutils.StringDeepCopy(*src.TagKeyName)
		}
		p.TagKeyName = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.TagValues != nil {
		p.TagValues = make([]*tag.TagValue, 0, len(src.TagValues))
		for _, elem := range src.TagValues {
			var _elem *tag.TagValue
			if elem != nil {
				_elem = &tag.TagValue{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.TagValues = append(p.TagValues, _elem)
		}
	}

	if src.ContentType != nil {
		tmp := *src.ContentType
		p.ContentType = &tmp
	}

	var _contentSpec *tag.TagContentSpec
	if src.ContentSpec != nil {
		_contentSpec = &tag.TagContentSpec{}
		if err := _contentSpec.DeepCopy(src.ContentSpec); err != nil {
			return err
		}
	}
	p.ContentSpec = _contentSpec

	return nil
}

func (p *ExptResultExportRecord) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetExportID bool = false
	var issetWorkspaceID bool = false
	var issetExptID bool = false
	var issetCsvExportStatus bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExportID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetWorkspaceID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExptID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCsvExportStatus = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetExportID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetWorkspaceID {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetExptID {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetCsvExportStatus {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ExptResultExportRecord[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_ExptResultExportRecord[fieldId]))
}

func (p *ExptResultExportRecord) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ExportID = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.WorkspaceID = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ExptID = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field CSVExportStatus
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.CsvExportStatus = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField5(buf []byte) (int, error) {
	offset := 0
	_field := common.NewBaseInfo()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BaseInfo = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.StartTime = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EndTime = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField8(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.URL = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField9(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Expired = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastReadField10(buf []byte) (int, error) {
	offset := 0
	_field := NewRunError()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Error = _field
	return offset, nil
}

func (p *ExptResultExportRecord) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ExptResultExportRecord) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField9(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ExptResultExportRecord) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ExptResultExportRecord) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ExportID)
	return offset
}

func (p *ExptResultExportRecord) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
	offset += thrift.Binary.WriteI64(buf[offset:], p.WorkspaceID)
	return offset
}

func (p *ExptResultExportRecord) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ExptID)
	return offset
}

func (p *ExptResultExportRecord) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
	offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, p.CsvExportStatus)
	return offset
}

func (p *ExptResultExportRecord) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBaseInfo() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 5)
		offset += p.BaseInfo.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExptResultExportRecord) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStartTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 6)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.StartTime)
	}
	return offset
}

func (p *ExptResultExportRecord) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEndTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 7)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.EndTime)
	}
	return offset
}

func (p *ExptResultExportRecord) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetURL() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 8)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.URL)
	}
	return offset
}

func (p *ExptResultExportRecord) fastWriteField9(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExpired() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 9)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.Expired)
	}
	return offset
}

func (p *ExptResultExportRecord) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetError() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 10)
		offset += p.Error.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ExptResultExportRecord) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExptResultExportRecord) field2Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExptResultExportRecord) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *ExptResultExportRecord) field4Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.StringLengthNocopy(p.CsvExportStatus)
	return l
}

func (p *ExptResultExportRecord) field5Length() int {
	l := 0
	if p.IsSetBaseInfo() {
		l += thrift.Binary.FieldBeginLength()
		l += p.BaseInfo.BLength()
	}
	return l
}

func (p *ExptResultExportRecord) field6Length() int {
	l := 0
	if p.IsSetStartTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ExptResultExportRecord) field7Length() int {
	l := 0
	if p.IsSetEndTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ExptResultExportRecord) field8Length() int {
	l := 0
	if p.IsSetURL() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.URL)
	}
	return l
}

func (p *ExptResultExportRecord) field9Length() int {
	l := 0
	if p.IsSetExpired() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *ExptResultExportRecord) field10Length() int {
	l := 0
	if p.IsSetError() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Error.BLength()
	}
	return l
}

func (p *ExptResultExportRecord) DeepCopy(s interface{}) error {
	src, ok := s.(*ExptResultExportRecord)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ExportID = src.ExportID

	p.WorkspaceID = src.WorkspaceID

	p.ExptID = src.ExptID

	p.CsvExportStatus = src.CsvExportStatus

	var _baseInfo *common.BaseInfo
	if src.BaseInfo != nil {
		_baseInfo = &common.BaseInfo{}
		if err := _baseInfo.DeepCopy(src.BaseInfo); err != nil {
			return err
		}
	}
	p.BaseInfo = _baseInfo

	if src.StartTime != nil {
		tmp := *src.StartTime
		p.StartTime = &tmp
	}

	if src.EndTime != nil {
		tmp := *src.EndTime
		p.EndTime = &tmp
	}

	if src.URL != nil {
		var tmp string
		if *src.URL != "" {
			tmp = kutils.StringDeepCopy(*src.URL)
		}
		p.URL = &tmp
	}

	if src.Expired != nil {
		tmp := *src.Expired
		p.Expired = &tmp
	}

	var _error *RunError
	if src.Error != nil {
		_error = &RunError{}
		if err := _error.DeepCopy(src.Error); err != nil {
			return err
		}
	}
	p.Error = _error

	return nil
}
